<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>redis on xiaoheiAh&#39;s blog</title><link>https://blog.xiaohei.im/tags/redis/</link><description>Recent content in redis on xiaoheiAh&#39;s blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>© Copyright notice</copyright><lastBuildDate>Sun, 24 Nov 2019 11:48:17 +0800</lastBuildDate><atom:link href="https://blog.xiaohei.im/tags/redis/feed.xml" rel="self" type="application/rss+xml"/><item><title>Redis HA - Cluster</title><link>https://blog.xiaohei.im/posts/redis/cluster/</link><pubDate>Sun, 24 Nov 2019 11:48:17 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/cluster/</guid><description>&lt;p&gt;Redis 官方高可用(HA)方案之一: &lt;strong&gt;Cluster&lt;/strong&gt;.可以解决 &lt;code&gt;sentinel&lt;/code&gt; 模式单点写入的问题.&lt;/p&gt;</description></item><item><title>Redis HA - 哨兵模式</title><link>https://blog.xiaohei.im/posts/redis/sentinel/</link><pubDate>Sat, 23 Nov 2019 17:56:15 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/sentinel/</guid><description>&lt;p&gt;Redis 官方高可用(HA)方案之一: &lt;strong&gt;哨兵模式&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Redis-复制功能探索</title><link>https://blog.xiaohei.im/posts/redis/replication/</link><pubDate>Sat, 16 Nov 2019 14:24:40 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/replication/</guid><description>&lt;p&gt;之前对&lt;code&gt;redis&lt;/code&gt; 的复制只有一点点了解,这次想要搞明白的是:如何实现的复制? 复制会遇到哪些问题(时延/一致性保证/网络故障时的处理)? 如何解决?高可用实现方案?&lt;/p&gt;
&lt;p&gt;文章有部分是直接翻译的 &lt;a href=&#34;https://redis.io/topics/replication&#34;&gt;https://redis.io/topics/replication&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Redis-事件</title><link>https://blog.xiaohei.im/posts/redis/event/</link><pubDate>Thu, 14 Nov 2019 15:01:45 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/event/</guid><description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;事件驱动程序设计&lt;/strong&gt;（英语：&lt;strong&gt;Event-driven programming&lt;/strong&gt;）是一种电脑&lt;a href=&#34;https://zh.wikipedia.org/wiki/程式設計&#34;&gt;程序设计&lt;/a&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/模型&#34;&gt;模型&lt;/a&gt;。这种模型的程序运行流程是由用户的动作（如&lt;a href=&#34;https://zh.wikipedia.org/wiki/滑鼠&#34;&gt;鼠标&lt;/a&gt;的按键，键盘的按键动作）或者是由其他程序的&lt;a href=&#34;https://zh.wikipedia.org/wiki/訊息&#34;&gt;消息&lt;/a&gt;来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由&lt;a href=&#34;https://zh.wikipedia.org/wiki/程式設計師&#34;&gt;程序员&lt;/a&gt;来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=互動程序&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;交互程序&lt;/a&gt;（Interactive program）的情况下孕育而生的。 &lt;a href=&#34;https://zh.wikipedia.org/wiki/事件驅動程式設計&#34;&gt;&amp;ndash;wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>Redis-AOF持久化</title><link>https://blog.xiaohei.im/posts/redis/aof/</link><pubDate>Fri, 08 Nov 2019 15:18:05 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/aof/</guid><description>&lt;p&gt;&lt;code&gt;RDB&lt;/code&gt; 和 &lt;code&gt;AOF&lt;/code&gt; 区别在于: 前者保存数据库快照,持久化所有键值对,后者通过保存 &lt;strong&gt;写命令&lt;/strong&gt; 保证数据库的状态.&lt;/p&gt;</description></item><item><title>Redis-RDB持久化</title><link>https://blog.xiaohei.im/posts/redis/rdb/</link><pubDate>Wed, 06 Nov 2019 19:08:56 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/rdb/</guid><description>&lt;p&gt;&lt;code&gt;redis&lt;/code&gt; 为内存数据库,一旦服务器进程退出,服务器中的数据就不见了.所以内存中的数据需要持久化的硬盘中来保证可以在必要的时候进行故障恢复. &lt;code&gt;RDB&lt;/code&gt; 就是 &lt;code&gt;redis&lt;/code&gt; 提供的一种持久化方式.&lt;/p&gt;</description></item><item><title>Redis-数据库长什么样?</title><link>https://blog.xiaohei.im/posts/redis/db/</link><pubDate>Wed, 06 Nov 2019 11:00:32 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/db/</guid><description/></item><item><title>Redis-万物皆「对象」</title><link>https://blog.xiaohei.im/posts/redis/obj/</link><pubDate>Mon, 04 Nov 2019 18:56:15 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/obj/</guid><description>&lt;p&gt;Redis有很多种数据结构,但其并没有直接使用这些数据结构来构建这个 &lt;code&gt;NOSQL&lt;/code&gt;, 而是通过 &lt;code&gt;对象系统&lt;/code&gt; 完成了对所有数据结构的统一管理, 实现内存回收, 对象共享等特性~&lt;/p&gt;</description></item><item><title>Redis-分布式锁</title><link>https://blog.xiaohei.im/posts/redis/distributed-lock/</link><pubDate>Sun, 03 Nov 2019 14:49:56 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/distributed-lock/</guid><description>&lt;p&gt;分布式锁有很多中实现(纯数据库,zookeeper,redis),纯数据库的受限于数据库性能,zk 可以保证加锁的顺序,是公平锁.Redis中的实现就是接下来要学习的.&lt;/p&gt;</description></item><item><title>Redis-数据结构</title><link>https://blog.xiaohei.im/posts/redis/data-structure/</link><pubDate>Thu, 24 Oct 2019 09:59:11 +0800</pubDate><guid>https://blog.xiaohei.im/posts/redis/data-structure/</guid><description>&lt;p&gt;系统学习 redis 相关的知识，从数据结构开始～&lt;/p&gt;</description></item></channel></rss>