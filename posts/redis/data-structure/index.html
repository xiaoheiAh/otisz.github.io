<!doctype html><html><head lang=zh><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Redis-数据结构 - xiaoheiAh&#39;s blog</title><link rel=icon type=image/png href=https://blog.xiaohei.im/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property=og:title content=Redis-数据结构><meta property=og:description content="「Redis 学习笔记」| 数据结构"><meta property=og:type content=article><meta property=og:url content=https://blog.xiaohei.im/posts/redis/data-structure/><meta property=article:published_time content=2019-10-24T09:59:11+08:00><meta property=article:modified_time content=2019-10-24T09:59:11+08:00><meta name=twitter:card content=summary><meta name=twitter:title content=Redis-数据结构><meta name=twitter:description content="「Redis 学习笔记」| 数据结构"><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/main.css><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/custom.css><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/dark.css media="(prefers-color-scheme: dark)"><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/custom-dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://blog.xiaohei.im/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://blog.xiaohei.im/>xiaoheiAh&#39;s blog</a></h1><div class=site-description><h2>Java Developer | 日常逛逛v站, 刷 github</h2><nav class="nav social"><ul class=flat><a href=https://github.com/xiaoheiAh title=xiaoheiAh><i data-feather=github></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/awesome>Awesome</a></li><li><a href=/cheatsheet>CheatSheet</a></li><li><a href=/about>About</a></li></ul></nav></div><div class=post-header><h1 class=title>Redis-数据结构</h1><div class=meta>Posted at &mdash; Oct 24, 2019</div></div><div class=markdown><p>系统学习 redis 相关的知识，从数据结构开始～</p><h2 id=string-字符串>String 字符串</h2><p>Redis 的字符串是 <strong>动态字符串</strong>, 长度可变，自动扩容。利用预分配空间方式减少内存的分配。默认分配 1M 大小的内存。扩容时加倍现有空间，最大占用为 <code>512M</code>.</p><h3 id=常用命令>常用命令</h3><p><a href=https://redis.io/commands/set>SET</a>,<a href=https://redis.io/commands/setnx>SETNX</a>&hellip;</p><h3 id=结构>结构</h3><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>struct</span> SDS<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
  T capacity; <span style=color:#586e75>// 数组容量
</span><span style=color:#586e75></span>  T len; <span style=color:#586e75>// 数组长度
</span><span style=color:#586e75></span>  byte flags; <span style=color:#586e75>// 特殊标识位，不理睬它
</span><span style=color:#586e75></span>  byte [] content; <span style=color:#586e75>// 数组内容
</span><span style=color:#586e75></span>}</code></pre></div><p>Redis 中的字符串叫做 <code>Simple Dynamic String</code>, 上述 <code>struct</code> 是一个简化版，实际的代码中，redis 会根据 str 的不同长度，使用不同的 <code>SDS</code>, 有 <code>sdshdr8</code>, <code>sdshdr16</code>, <code>sdshdr32</code> 等等&hellip; 但结构体都是如上的类型.</p><p><code>capacity</code> 存储数组的长度，<code>len</code> 表示数组的实际长度。需要注意的是: string 的字符串是以 <code>\0</code> 结尾的，这样可以便于调试打印，还可以直接使用 <code>glibc</code> 的字符串函数进行操作.</p><h3 id=字符串存储>字符串存储</h3><p>字符串有两种存储方式，长度很短时，使用 <code>emb</code> 形式存储，长度超过 <code>44</code> 时，使用 <code>raw</code> 形式存储.</p><p>可以使用 <code>debug object {your_string}</code> 来查看存储形式</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&gt; <span style=color:#b58900>set</span> codehole abcdefghijklmnopqrstuvwxyz012345678912345678
OK
&gt; debug object codehole
Value at:0x7fec2de00370 refcount:1 encoding:embstr serializedlength:45 lru:5958906 lru_seconds_idle:1
&gt; <span style=color:#b58900>set</span> codehole abcdefghijklmnopqrstuvwxyz0123456789123456789
OK
&gt; debug object codehole
Value at:0x7fec2dd0b750 refcount:1 encoding:raw serializedlength:46 lru:5958911 lru_seconds_idle:1</code></pre></div><h4 id=why>WHY?</h4><p>首先需要解释 <code>RedisObject</code>, 所有 Redis 对象都有的结构体</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>struct</span> RedisObject {
    int4 type; <span style=color:#586e75>// 4bits
</span><span style=color:#586e75></span>    int4 encoding; <span style=color:#586e75>// 4bits
</span><span style=color:#586e75></span>    int24 lru; <span style=color:#586e75>// 24bits
</span><span style=color:#586e75></span>    int32 refcount; <span style=color:#586e75>// 4bytes
</span><span style=color:#586e75></span>    <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>ptr; <span style=color:#586e75>// 8bytes，64-bit system
</span><span style=color:#586e75></span>} robj;</code></pre></div><p>不同的对象具有不同的类型 <code>type (4bit)</code>，同一个类型的 type 会有不同的存储形式 <code>encoding (4bit)</code>，为了记录对象的 LRU 信息，使用了 24 个 bit 来记录 LRU 信息。每个对象都有个引用计数，当引用计数为零时，对象就会被销毁，内存被回收。<code>ptr</code> 指针将指向对象内容 (body) 的具体存储位置。这样一个 RedisObject 对象头需要占据 16 字节的存储空间。</p><p>接着我们再看 SDS 结构体的大小，在字符串比较小时，SDS 对象头的大小是 <code>capacity+3</code>，至少是 3。意味着分配一个字符串的最小空间占用为 19 字节 (16+3)。</p><p>一张图解释:</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191028154142.png alt=sds></p><h2 id=list-列表>List 列表</h2><p>Redis 的列表是用链表来实现的，插入删除 <code>O (1)</code>, 查找 <code>O (n)</code>, 列表弹出最后一个元素时，数据结构删除，内存回收.</p><h3 id=常用命令-1>常用命令</h3><p><a href=https://redis.io/commands/lpush>LPUSH</a>,<a href=https://redis.io/commands/lpop>LPOP</a>,<a href=https://redis.io/commands/rpush>RPUSH</a>,<a href=https://redis.io/commands/rpop>RPOP</a>,<a href=https://redis.io/commands/lrange>LRANGE</a>&hellip;</p><h3 id=列表的数据结构>列表的数据结构</h3><p>列表底层的存储结构并不是简简单单的一个链表～通过 <code>ziplist</code> 连接起来组成 <code>quicklist</code>.</p><h4 id=ziplist-压缩列表>ziplist 压缩列表</h4><p>在列表元素较少时，redis 会使用一块连续内存来进行存储，这个结构就是 <code>ziplist</code>. 所有的元素紧挨着存储.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&gt; zadd z_lang <span style=color:#2aa198>1</span> java <span style=color:#2aa198>2</span> rust <span style=color:#2aa198>3</span> go
<span style=color:#719e07>(</span>integer<span style=color:#719e07>)</span> <span style=color:#2aa198>3</span>
&gt; debug object z_lang
Value at:0x7fde1c466660 refcount:1 encoding:ziplist serializedlength:34 lru:11974320 lru_seconds_idle:11</code></pre></div><p>可以看到上述输出 <code>encoding</code> 为 <code>ziplist</code>.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>struct</span> ziplist<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
    int32 zlbytes; <span style=color:#586e75>// 整个压缩列表占用字节数
</span><span style=color:#586e75></span>    int32 zltail_offset; <span style=color:#586e75>// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
</span><span style=color:#586e75></span>    int16 zllength; <span style=color:#586e75>// 元素个数
</span><span style=color:#586e75></span>    T [] entries; <span style=color:#586e75>// 元素内容列表，挨个挨个紧凑存储
</span><span style=color:#586e75></span>    int8 zlend; <span style=color:#586e75>// 标志压缩列表的结束，值恒为 0xFF
</span><span style=color:#586e75></span>}</code></pre></div><p><code>zltail_offset</code> 是为了支持双向遍历才设计的，可以快速定位到最后一个元素，然后倒着遍历.</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191028174656.png alt=ziplist结构></p><p><code>entry</code> 会随着容纳的元素不同而结构不同.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>struct</span> entry {
    <span style=color:#dc322f>int</span><span style=color:#719e07>&lt;</span>var<span style=color:#719e07>&gt;</span> prevlen; <span style=color:#586e75>// 前一个 entry 的字节长度
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span><span style=color:#719e07>&lt;</span>var<span style=color:#719e07>&gt;</span> encoding; <span style=color:#586e75>// 元素类型编码
</span><span style=color:#586e75></span>    optional byte [] content; <span style=color:#586e75>// 元素内容
</span><span style=color:#586e75></span>}</code></pre></div><p><code>prevlen</code> 表示前一个 entry 的字节长度，倒序遍历时，可以根据这个字段来推算前一个 entry 的位置。它是变长的整数，字符串长度小于 254 ( <code>0XFE</code> ) 时，使用一个字节表示，大于等于 254, 使用 5 个字节来表示。第一个字节是 254, 剩余四个字节表示字符串长度.</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191028175143.png alt=ziplist-entry></p><h5 id=encoding-编码类型>encoding 编码类型</h5><p><code>encoding</code> 存储编码类型信息，<code>ziplist</code> 通过其来决定 <code>content</code> 内容的形式。所以其设计是很复杂的.</p><ol><li><code>00xxxxxx</code> 最大长度位 63 的短字符串，后面的 6 个位存储字符串的位数，剩余的字节就是字符串的内容。</li><li><code>01xxxxxx xxxxxxxx</code> 中等长度的字符串，后面 14 个位来表示字符串的长度，剩余的字节就是字符串的内容。</li><li><code>10000000 aaaaaaaa bbbbbbbb cccccccc dddddddd</code> 特大字符串，需要使用额外 4 个字节来表示长度。第一个字节前缀是 <code>10</code>，剩余 6 位没有使用，统一置为零。后面跟着字符串内容。不过这样的大字符串是没有机会使用的，压缩列表通常只是用来存储小数据的。</li><li><code>11000000</code> 表示 int16，后跟两个字节表示整数。</li><li><code>11010000</code> 表示 int32，后跟四个字节表示整数。</li><li><code>11100000</code> 表示 int64，后跟八个字节表示整数。</li><li><code>11110000</code> 表示 int24，后跟三个字节表示整数。</li><li><code>11111110</code> 表示 int8，后跟一个字节表示整数。</li><li><code>11111111</code> 表示 ziplist 的结束，也就是 zlend 的值 0xFF。</li><li><code>1111xxxx</code> 表示极小整数，xxxx 的范围只能是 (<code>0001~1101</code>), 也就是 <code>1~13</code>，因为 <code>0000、1110、1111</code> 都被占用了。读取到的 value 需要将 xxxx 减 1，也就是整数 <code>0~12</code> 就是最终的 value。</li></ol><h5 id=增加元素>增加元素</h5><p><code>ziplist</code> 是连续存储的，没有多余空间，这意味着每次插入一个元素，就需要扩展内存。如果占用内存过大，重新分配内存和拷贝内存就会有很大的消耗。所以其缺点是不适合存储 <strong>大型字符串</strong>, 存储元素不宜 <strong>过多</strong>.</p><h5 id=级联更新>级联更新</h5><p>每一个 entry 都是有 <code>prevlen</code>, 而且时而为 1 字节存储，时而为 5 字节存储，取决于字符串的字节长度是否大于 <strong>254</strong>, 如果某次操作导致字节长度从 254 变为 256, 那么其下一个节点所存储的 <code>prevlen</code> 就要从 1 个字节变为 5 个字节来存储，如果下一个节点刚好因此超过了 254 的长度，那么下下个节点也要更新&hellip; 这就是级联更新了～</p><h4 id=quicklist>quicklist</h4><p>Redis 中 list 的存储结构就是 <code>quicklist</code>. 下面的 language 是一个记录编程语言的集合。可以看到 <code>encoding</code> 即为 <code>quicklist</code>.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&gt; debug object language
Value at:0x7fde1c4665f0 refcount:1 encoding:quicklist serializedlength:29 lru:11974264 lru_seconds_idle:62740 ql_nodes:1 ql_avg_node:3.00 ql_ziplist_max:-2 ql_compressed:0 ql_uncompressed_size:27</code></pre></div><p>Redis 的 <code>quicklist</code> 是一种基于 <code>ziplist</code> 实现的可压缩（<code>quicklistLZF</code>）的双向链表，结合了链表和 ziplist 的 <code>优点</code> 组成的。下面可以看下他的结构体.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#586e75>/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
</span><span style=color:#586e75> * &#39;count&#39; is the number of total entries.
</span><span style=color:#586e75> * &#39;len&#39; is the number of quicklist nodes.
</span><span style=color:#586e75> * &#39;compress&#39; is: -1 if compression disabled, otherwise it&#39;s the number
</span><span style=color:#586e75> *                of quicklistNodes to leave uncompressed at ends of quicklist.
</span><span style=color:#586e75> * &#39;fill&#39; is the user-requested (or default) fill factor. */</span>
<span style=color:#586e75>/**
</span><span style=color:#586e75> * quicklist 是一个 40byte (64 位系统) 的结构
</span><span style=color:#586e75> */</span>
<span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> quicklist {
    quicklistNode <span style=color:#719e07>*</span>head;
    quicklistNode <span style=color:#719e07>*</span>tail;
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> count;        <span style=color:#586e75>/* 元素总数 */</span>
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> len;          <span style=color:#586e75>/* quicklistNode 的长度 */</span>
    <span style=color:#dc322f>int</span> fill : <span style=color:#2aa198>16</span>;              <span style=color:#586e75>/* ziplist 的最大长度 */</span>
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> compress : <span style=color:#2aa198>16</span>; <span style=color:#586e75>/* 节点压缩深度 */</span>
} quicklist;

<span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> quicklistNode {
    <span style=color:#719e07>struct</span> quicklistNode <span style=color:#719e07>*</span>prev;
    <span style=color:#719e07>struct</span> quicklistNode <span style=color:#719e07>*</span>next;
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>zl; <span style=color:#586e75>/* 没有压缩，指向 ziplist, 否则指向 quicklistLZF
</span><span style=color:#586e75>    unsigned int sz;   /* ziplist 字节总数 */</span>
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> count : <span style=color:#2aa198>16</span>;     <span style=color:#586e75>/* ziplist 元素数量 */</span>
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> encoding : <span style=color:#2aa198>2</span>;   <span style=color:#586e75>/* RAW==1 or LZF==2 */</span>
		...
} quicklistNode;

<span style=color:#586e75>//LZF 无损压缩算法，压缩过的 ziplist
</span><span style=color:#586e75></span><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> quicklistLZF {
    <span style=color:#586e75>// 未压缩之前的大小
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> sz; <span style=color:#586e75>/* LZF size in bytes*/</span>
    <span style=color:#586e75>// 存放压缩过的 ziplist 数组
</span><span style=color:#586e75></span>    <span style=color:#dc322f>char</span> compressed [];
} quicklistLZF;</code></pre></div><h5 id=一张图展示结构>一张图展示结构</h5><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191029112957.png alt=quicklist></p><h5 id=压缩深度>压缩深度</h5><p><code>quicklist</code> 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数 <code>list-compress-depth</code> 决定。为了支持快速的 push/pop 操作，<code>quicklist</code> 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p><h2 id=set-集合>Set 集合</h2><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值<code>NULL</code>。</p><h3 id=常用命令-2>常用命令</h3><p><a href=https://redis.io/commands/sadd>SADD</a>,<a href=https://redis.io/commands/smembers>SMEMBERS</a>,<a href=https://redis.io/commands/spop>SPOP</a>,<a href=https://redis.io/commands/sismember>SISMEMBER</a>,<a href=https://redis.io/commands/scard>SCARD</a>&hellip;</p><h2 id=hash-哈希>Hash 哈希</h2><p>Redis 的 Hash相当于Java 中的 HashMap, 数组 + 链表的二维结构.与 HashMap 不同的地方在于 <code>rehash</code> 方式不同, HashMap 中的 <code>rehash</code> 是阻塞式的, 需要一次性全部 <code>rehash</code>, 而 redis 为了性能考虑, 采用的是 <code>渐进式 rehash</code>.</p><h3 id=常用命令-3>常用命令</h3><p><a href=https://redis.io/commands/hset>HSET</a>,<a href=https://redis.io/commands/hget>HGET</a>,<a href=https://redis.io/commands/hmset>HMSET</a>,<a href=https://redis.io/commands/hlen>HLEN</a>&hellip;</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&gt; hset books java <span style=color:#2aa198>&#34;think in java&#34;</span>  <span style=color:#586e75># 命令行的字符串如果包含空格，要用引号括起来</span>
<span style=color:#719e07>(</span>integer<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span>
&gt; hset books golang <span style=color:#2aa198>&#34;concurrency in go&#34;</span>
<span style=color:#719e07>(</span>integer<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span>
&gt; hset books python <span style=color:#2aa198>&#34;python cookbook&#34;</span>
<span style=color:#719e07>(</span>integer<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span>
&gt; hgetall books  <span style=color:#586e75># entries()，key 和 value 间隔出现</span>
<span style=color:#2aa198>1</span><span style=color:#719e07>)</span> <span style=color:#2aa198>&#34;java&#34;</span>
<span style=color:#2aa198>2</span><span style=color:#719e07>)</span> <span style=color:#2aa198>&#34;think in java&#34;</span>
<span style=color:#2aa198>3</span><span style=color:#719e07>)</span> <span style=color:#2aa198>&#34;golang&#34;</span>
<span style=color:#2aa198>4</span><span style=color:#719e07>)</span> <span style=color:#2aa198>&#34;concurrency in go&#34;</span>
<span style=color:#2aa198>5</span><span style=color:#719e07>)</span> <span style=color:#2aa198>&#34;python&#34;</span>
<span style=color:#2aa198>6</span><span style=color:#719e07>)</span> <span style=color:#2aa198>&#34;python cookbook&#34;</span>
&gt; hlen books
<span style=color:#719e07>(</span>integer<span style=color:#719e07>)</span> <span style=color:#2aa198>3</span>
&gt; hget books java
<span style=color:#2aa198>&#34;think in java&#34;</span>
&gt; hset books golang <span style=color:#2aa198>&#34;learning go programming&#34;</span>  <span style=color:#586e75># 因为是更新操作，所以返回 0</span>
<span style=color:#719e07>(</span>integer<span style=color:#719e07>)</span> <span style=color:#2aa198>0</span>
&gt; hget books golang
<span style=color:#2aa198>&#34;learning go programming&#34;</span>
&gt; hmset books java <span style=color:#2aa198>&#34;effective java&#34;</span> python <span style=color:#2aa198>&#34;learning python&#34;</span> golang <span style=color:#2aa198>&#34;modern golang programming&#34;</span>  <span style=color:#586e75># 批量 set</span>
OK</code></pre></div><h3 id=字典>字典</h3><p>Redis 的 Hash 是通过 <code>dict</code> 结构来实现的, 该结构的底层是由哈希表来实现.类似于 HashMap, 数组+链表, 超过负载因子所对应的阈值时,进行 <code>rehash</code>, 扩容. 在具体实现中,使用了渐进式hash的方式来避免 HashMap 这种阻塞式的 rehash, 将 rehash 的工作分摊到对字典的增删改查中.</p><h4 id=struct>struct</h4><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> dictEntry {
    <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>key; <span style=color:#586e75>//键
</span><span style=color:#586e75></span>    <span style=color:#719e07>union</span> {
        <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>val;  <span style=color:#586e75>//值
</span><span style=color:#586e75></span>        uint64_t u64;
        int64_t s64;
        <span style=color:#dc322f>double</span> d;
    } v;
    <span style=color:#719e07>struct</span> dictEntry <span style=color:#719e07>*</span>next; <span style=color:#586e75>//指向下一节点,形成链表
</span><span style=color:#586e75></span>} dictEntry;

<span style=color:#586e75>/* This is our hash table structure. Every dictionary has two of this as we
</span><span style=color:#586e75> * implement incremental rehashing, for the old to the new table. */</span>
<span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> dictht {
    dictEntry <span style=color:#719e07>**</span>table; <span style=color:#586e75>// 哈希表数组,数组的每一项都是 distEntry 的头结点
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> size; <span style=color:#586e75>// 哈希表的大小,也是触发扩容的阈值
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> sizemask; <span style=color:#586e75>// 哈希表大小掩码,用于计算索引值,总是等于 size-1
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> used; <span style=color:#586e75>// 哈希表中实际保存的节点数量
</span><span style=color:#586e75></span>} dictht;

<span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> dict {
    dictType <span style=color:#719e07>*</span>type; <span style=color:#586e75>//属性是一个指向 dictType 结构的指针,每个 dictType 结构保存了一簇用于操作特定类型键值对的函数,Redis 会为用途不同的字典设置不同的类型特定函数
</span><span style=color:#586e75></span>    <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>privdata; <span style=color:#586e75>// 保存了需要传给那些类型特定函数的可选参数
</span><span style=color:#586e75></span>    dictht ht[<span style=color:#2aa198>2</span>]; <span style=color:#586e75>// 在字典内部,维护了两张哈希表. 一般情况下,字典只使用 ht[0] 哈希表,ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用
</span><span style=color:#586e75></span>    <span style=color:#dc322f>long</span> rehashidx; <span style=color:#586e75>// 记录 rehash 的状态, 没有进行 rehash 则为 -1
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> iterators; <span style=color:#586e75>/* number of iterators currently running */</span>
} dict;</code></pre></div><h4 id=一张图来表示>一张图来表示</h4><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191103120536.png alt=图片来自美团技术博客></p><h4 id=何时扩容>何时扩容?</h4><p>找到<code>dictAddRow</code> 函数观察源码可以发现,会在 <code>_dictExpandIfNeeded</code> 函数中进行扩容的判断.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#586e75>/* Expand the hash table if needed */</span>
<span style=color:#719e07>static</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>_dictExpandIfNeeded</span>(dict <span style=color:#719e07>*</span>d)
{
    <span style=color:#586e75>/* Incremental rehashing already in progress. Return. */</span>
  	<span style=color:#586e75>// 正在渐进式扩容, 就返回 OK
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (dictIsRehashing(d)) <span style=color:#719e07>return</span> DICT_OK;

    <span style=color:#586e75>/* If the hash table is empty expand it to the initial size. */</span>
  	<span style=color:#586e75>// 如果哈希表 ht[0] size 为 0 ,初始化, 说明 redis 是懒加载的,延长初始化策略
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].size <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span>) <span style=color:#719e07>return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);

    <span style=color:#586e75>/* If we reached the 1:1 ratio, and we are allowed to resize the hash
</span><span style=color:#586e75>     * table (global setting) or we should avoid it but the ratio between
</span><span style=color:#586e75>     * elements/buckets is over the &#34;safe&#34; threshold, we resize doubling
</span><span style=color:#586e75>     * the number of buckets. */</span>
    <span style=color:#586e75>/*
</span><span style=color:#586e75>     * 如果哈希表ht[0]中保存的key个数与哈希表大小的比例已经达到1:1，即保存的节点数已经大于哈希表大小
</span><span style=color:#586e75>     * 且redis服务当前允许执行rehash，或者保存的节点数与哈希表大小的比例超过了安全阈值（默认值为5）
</span><span style=color:#586e75>     * 则将哈希表大小扩容为原来的两倍
</span><span style=color:#586e75>     */</span>
    <span style=color:#719e07>if</span> (d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].used <span style=color:#719e07>&gt;=</span> d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].size <span style=color:#719e07>&amp;&amp;</span>
        (dict_can_resize <span style=color:#719e07>||</span>
         d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].used<span style=color:#719e07>/</span>d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].size <span style=color:#719e07>&gt;</span> dict_force_resize_ratio))
    {
        <span style=color:#719e07>return</span> dictExpand(d, d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].used<span style=color:#719e07>*</span><span style=color:#2aa198>2</span>);
    }
    <span style=color:#719e07>return</span> DICT_OK;
}</code></pre></div><p>正常情况下，当 hash 表中元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是原数组大小的 2 倍。不过如果 Redis 正在做 bgsave，为了减少内存页的过多分离 (Copy On Write)，Redis 尽量不去扩容 (<code>dict_can_resize</code>)，但是如果 hash 表已经非常满了，元素的个数已经达到了第一维数组长度的 5 倍 (<code>dict_force_resize_ratio</code>)，说明 hash 表已经过于拥挤了，这个时候就会强制扩容。</p><h4 id=何时缩容>何时缩容?</h4><p>当哈希表的负载因子小于 0.1 时,自动缩容.这个操作会在 redis 的定时任务中来完成.函数为 <code>databasesCron</code>,该函数的作用是在后台慢慢的处理过期,<code>rehashing</code>, 缩容.</p><p><strong>执行条件:</strong> 没有子进程执行aof重写或者生成RDB文件</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#586e75>/* 遍历所有的redis数据库,尝试缩容 */</span>
<span style=color:#719e07>for</span> (j <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; j <span style=color:#719e07>&lt;</span> dbs_per_call; j<span style=color:#719e07>++</span>) {
  tryResizeHashTables(resize_db <span style=color:#719e07>%</span> server.dbnum);
  resize_db<span style=color:#719e07>++</span>;
}
<span style=color:#586e75>/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL
</span><span style=color:#586e75> * we resize the hash table to save memory */</span>
<span style=color:#dc322f>void</span> tryResizeHashTables(<span style=color:#dc322f>int</span> dbid) {
    <span style=color:#719e07>if</span> (htNeedsResize(server.db[dbid].dict))
        dictResize(server.db[dbid].dict);
    <span style=color:#719e07>if</span> (htNeedsResize(server.db[dbid].expires))
        dictResize(server.db[dbid].expires);
}
<span style=color:#586e75>/* Hash table parameters */</span>
<span style=color:#719e07>#define HASHTABLE_MIN_FILL        10      </span><span style=color:#586e75>/* Minimal hash table fill 10% */</span><span style=color:#719e07>
</span><span style=color:#719e07></span><span style=color:#dc322f>int</span> htNeedsResize(dict <span style=color:#719e07>*</span>dict) {
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> size, used;

    size <span style=color:#719e07>=</span> dictSlots(dict);
    used <span style=color:#719e07>=</span> dictSize(dict);
    <span style=color:#719e07>return</span> (size <span style=color:#719e07>&gt;</span> DICT_HT_INITIAL_SIZE <span style=color:#719e07>&amp;&amp;</span>
            (used<span style=color:#719e07>*</span><span style=color:#2aa198>100</span><span style=color:#719e07>/</span>size <span style=color:#719e07>&lt;</span> HASHTABLE_MIN_FILL));
}
<span style=color:#586e75>/* Resize the table to the minimal size that contains all the elements,
</span><span style=color:#586e75> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span>
<span style=color:#dc322f>int</span> dictResize(dict <span style=color:#719e07>*</span>d)
{
    <span style=color:#dc322f>int</span> minimal;

    <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>dict_can_resize <span style=color:#719e07>||</span> dictIsRehashing(d)) <span style=color:#719e07>return</span> DICT_ERR;
    minimal <span style=color:#719e07>=</span> d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].used;
    <span style=color:#719e07>if</span> (minimal <span style=color:#719e07>&lt;</span> DICT_HT_INITIAL_SIZE)
        minimal <span style=color:#719e07>=</span> DICT_HT_INITIAL_SIZE;
    <span style=color:#719e07>return</span> <span style=color:#268bd2>dictExpand</span>(d, minimal);
}</code></pre></div><p>从 <code>htNeedsResize</code>函数中可以看到,当哈希表保存的key数量与哈希表的大小的比例小于10%时需要缩容.最小容量为<code>DICT_HT_INITIAL_SIZE = 4</code>. <code>dictResize</code> 函数中,当正在执行 aof 重写或生成 rdb 时, <code>dict_can_resize</code> 会变为 0, 也就说明上面的 <strong>执行条件</strong>.</p><h4 id=渐进式-rehash>渐进式 rehash</h4><p>从上述源码中可以看出,所有的扩容或者创建都经过 <code>dictExpand</code> 函数.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#586e75>/* Expand or create the hash table */</span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>dictExpand</span>(dict <span style=color:#719e07>*</span>d, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> size)
{
    <span style=color:#586e75>/* the size is invalid if it is smaller than the number of
</span><span style=color:#586e75>     * elements already inside the hash table */</span>
    <span style=color:#719e07>if</span> (dictIsRehashing(d) <span style=color:#719e07>||</span> d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].used <span style=color:#719e07>&gt;</span> size)
        <span style=color:#719e07>return</span> DICT_ERR;
		<span style=color:#586e75>// 计算新的哈希表大小,获得大于等于size的第一个2次方
</span><span style=color:#586e75></span>    dictht n; <span style=color:#586e75>/* the new hash table */</span>
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> realsize <span style=color:#719e07>=</span> _dictNextPower(size);

    <span style=color:#586e75>/* Rehashing to the same table size is not useful. */</span>
    <span style=color:#719e07>if</span> (realsize <span style=color:#719e07>==</span> d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].size) <span style=color:#719e07>return</span> DICT_ERR;

    <span style=color:#586e75>/* Allocate the new hash table and initialize all pointers to NULL */</span>
    n.size <span style=color:#719e07>=</span> realsize;
    n.sizemask <span style=color:#719e07>=</span> realsize<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>;
    n.table <span style=color:#719e07>=</span> zcalloc(realsize<span style=color:#719e07>*</span><span style=color:#719e07>sizeof</span>(dictEntry<span style=color:#719e07>*</span>));
    n.used <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;

    <span style=color:#586e75>/* Is this the first initialization? If so it&#39;s not really a rehashing
</span><span style=color:#586e75>     * we just set the first hash table so that it can accept keys. */</span>
  	<span style=color:#586e75>// 第一次初始化也会通过这里来完成创建
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>].table <span style=color:#719e07>==</span> <span style=color:#b58900>NULL</span>) {
        d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>0</span>] <span style=color:#719e07>=</span> n;
        <span style=color:#719e07>return</span> DICT_OK;
    }

    <span style=color:#586e75>/* Prepare a second hash table for incremental rehashing */</span>
  	<span style=color:#586e75>// ht[1] 开始派上用场,扩容时是在 ht[1] 上操作, rehash 完毕后,在交换到 ht[0]
</span><span style=color:#586e75></span>    d<span style=color:#719e07>-&gt;</span>ht[<span style=color:#2aa198>1</span>] <span style=color:#719e07>=</span> n;
    d<span style=color:#719e07>-&gt;</span>rehashidx <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
    <span style=color:#719e07>return</span> DICT_OK;
}</code></pre></div><p>从 <code>dictExpand</code> 这个函数可以发现做了这么几件事:</p><ol><li>校验是否可以执行 <code>rehash</code></li><li>创建一个新的哈希表 <code>n</code>, 分配更大的内存</li><li>将哈希表 <code>n</code> 复制给 <code>ht[1]</code>, 将 <code>rehashidx</code> 标志置为 0 ,意味着开启了渐进式rehash. 该值也标志渐进式rehash当前已经进行到了哪个hash槽.</li></ol><p>该函数没有将key重新 <code>rehash</code> 到新的 <code>slot</code> 上,而是交由增删改查的操作, 以及后台定时任务来处理.</p><h5 id=增删改查辅助rehash>增删改查辅助rehash</h5><p>看源码其实可以发现在所有增删改查的源码中,开头都会有一个判断,是否处于渐进式rehash中.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>dictEntry <span style=color:#719e07>*</span><span style=color:#268bd2>dictAddRaw</span>(dict <span style=color:#719e07>*</span>d, <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>key, dictEntry <span style=color:#719e07>**</span>existing)
{
    <span style=color:#dc322f>long</span> index;
    dictEntry <span style=color:#719e07>*</span>entry;
    dictht <span style=color:#719e07>*</span>ht;

    <span style=color:#719e07>if</span> (dictIsRehashing(d)) _dictRehashStep(d);
		...
}
<span style=color:#586e75>// 进入 rehash 后是 &gt;=0的值
</span><span style=color:#586e75></span><span style=color:#719e07>#define dictIsRehashing(d) ((d)-&gt;rehashidx != -1)
</span><span style=color:#719e07></span><span style=color:#586e75>/*
</span><span style=color:#586e75> * 此函数仅执行一步hash表的重散列，并且仅当没有安全迭代器绑定到哈希表时。
</span><span style=color:#586e75> * 当我们在重新散列中有迭代器时，我们不能混淆打乱两个散列表的数据，否则某些元素可能被遗漏或重复遍历。
</span><span style=color:#586e75> *
</span><span style=color:#586e75> * 该函数被在字典中查找或更新等普通操作调用，以致字典中的数据能自动的从哈系表１迁移到哈系表２
</span><span style=color:#586e75> */</span>
<span style=color:#719e07>static</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>_dictRehashStep</span>(dict <span style=color:#719e07>*</span>d) {
    <span style=color:#719e07>if</span> (d<span style=color:#719e07>-&gt;</span>iterators <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span>) dictRehash(d,<span style=color:#2aa198>1</span>);
}</code></pre></div><h5 id=后台任务rehash>后台任务rehash</h5><p>虽然redis实现了在读写操作时,辅助服务器进行渐进式rehash操作,但是如果服务器比较空闲,redis数据库将很长时间内都一直使用两个哈希表.所以在redis周期函数中,如果发现有字典正在进行渐进式rehash操作,则会花费<strong>1毫秒</strong>的时间,帮助一起进行渐进式rehash操作.</p><p>还是上面缩容时使用的任务函数<code>databasesCron</code>.源码如下:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#586e75>/* Rehash */</span>
<span style=color:#719e07>if</span> (server.activerehashing) {
  <span style=color:#719e07>for</span> (j <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; j <span style=color:#719e07>&lt;</span> dbs_per_call; j<span style=color:#719e07>++</span>) {
    <span style=color:#dc322f>int</span> work_done <span style=color:#719e07>=</span> incrementallyRehash(rehash_db);
    <span style=color:#719e07>if</span> (work_done) {
      <span style=color:#586e75>/* If the function did some work, stop here, we&#39;ll do
</span><span style=color:#586e75>                 * more at the next cron loop. */</span>
      <span style=color:#719e07>break</span>;
    } <span style=color:#719e07>else</span> {
      <span style=color:#586e75>/* If this db didn&#39;t need rehash, we&#39;ll try the next one. */</span>
      rehash_db<span style=color:#719e07>++</span>;
      rehash_db <span style=color:#719e07>%=</span> server.dbnum;
    }
  }
}</code></pre></div><h4 id=渐进式rehash弊端>渐进式rehash弊端</h4><p>渐进式rehash避免了redis阻塞,可以说非常完美,但是由于在rehash时,需要分配一个新的hash表,在rehash期间,同时有两个hash表在使用,会使得redis内存使用量瞬间突增,在Redis 满容状态下由于Rehash会导致大量Key驱逐.</p><h2 id=zset-有序集合>Zset 有序集合</h2><p>首先 <code>zset</code> 是一个 <code>set</code> 结构,拥有 <code>set</code> 的所有特性,其次他可以给每一个 <code>value</code> 赋予一个 <code>score</code> 作为权重.内部实现用的跳表(<code>skiplist</code>)</p><h3 id=常用命令-4>常用命令</h3><p><a href=https://redis.io/commands/zadd>ZADD</a>,<a href=https://redis.io/commands/zrange>ZRANGE</a>,<a href=https://redis.io/commands/zrevrange>ZREVRANGE</a>,<a href=https://redis.io/commands/zscore>ZSCORE</a>,<a href=https://redis.io/commands/zcard>ZCARD</a>,<a href=https://redis.io/commands/zrank>ZRANK</a>&hellip;</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>&gt;</span> zadd books <span style=color:#2aa198>9.0</span> <span style=color:#2aa198>&#34;think in java&#34;</span>
(integer) <span style=color:#2aa198>1</span>
<span style=color:#719e07>&gt;</span> zadd books <span style=color:#2aa198>8.9</span> <span style=color:#2aa198>&#34;java concurrency&#34;</span>
(integer) <span style=color:#2aa198>1</span>
<span style=color:#719e07>&gt;</span> zadd books <span style=color:#2aa198>8.6</span> <span style=color:#2aa198>&#34;java cookbook&#34;</span>
(integer) <span style=color:#2aa198>1</span>
<span style=color:#719e07>&gt;</span> zrange books <span style=color:#2aa198>0</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>  # 按 score 排序列出，参数区间为排名范围
<span style=color:#2aa198>1</span>) <span style=color:#2aa198>&#34;java cookbook&#34;</span>
<span style=color:#2aa198>2</span>) <span style=color:#2aa198>&#34;java concurrency&#34;</span>
<span style=color:#2aa198>3</span>) <span style=color:#2aa198>&#34;think in java&#34;</span>
<span style=color:#719e07>&gt;</span> zrevrange books <span style=color:#2aa198>0</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>  # 按 score 逆序列出，参数区间为排名范围
<span style=color:#2aa198>1</span>) <span style=color:#2aa198>&#34;think in java&#34;</span>
<span style=color:#2aa198>2</span>) <span style=color:#2aa198>&#34;java concurrency&#34;</span>
<span style=color:#2aa198>3</span>) <span style=color:#2aa198>&#34;java cookbook&#34;</span>
<span style=color:#719e07>&gt;</span> zcard books  # 相当于 count()
(integer) <span style=color:#2aa198>3</span>
<span style=color:#719e07>&gt;</span> zscore books <span style=color:#2aa198>&#34;java concurrency&#34;</span>  # 获取指定 value 的 score
<span style=color:#2aa198>&#34;8.9000000000000004&#34;</span>  # 内部 score 使用 <span style=color:#dc322f>double</span> 类型进行存储，所以存在小数点精度问题
<span style=color:#719e07>&gt;</span> zrank books <span style=color:#2aa198>&#34;java concurrency&#34;</span>  # 排名
(integer) <span style=color:#2aa198>1</span>
<span style=color:#719e07>&gt;</span> zrangebyscore books <span style=color:#2aa198>0</span> <span style=color:#2aa198>8.91</span>  # 根据分值区间遍历 zset
<span style=color:#2aa198>1</span>) <span style=color:#2aa198>&#34;java cookbook&#34;</span>
<span style=color:#2aa198>2</span>) <span style=color:#2aa198>&#34;java concurrency&#34;</span>
<span style=color:#719e07>&gt;</span> zrangebyscore books <span style=color:#719e07>-</span>inf <span style=color:#2aa198>8.91</span> withscores # 根据分值区间 (<span style=color:#719e07>-</span>∞, <span style=color:#2aa198>8.91</span>] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。
<span style=color:#2aa198>1</span>) <span style=color:#2aa198>&#34;java cookbook&#34;</span>
<span style=color:#2aa198>2</span>) <span style=color:#2aa198>&#34;8.5999999999999996&#34;</span>
<span style=color:#2aa198>3</span>) <span style=color:#2aa198>&#34;java concurrency&#34;</span>
<span style=color:#2aa198>4</span>) <span style=color:#2aa198>&#34;8.9000000000000004&#34;</span>
<span style=color:#719e07>&gt;</span> zrem books <span style=color:#2aa198>&#34;java concurrency&#34;</span>  # 删除 value
(integer) <span style=color:#2aa198>1</span>
<span style=color:#719e07>&gt;</span> zrange books <span style=color:#2aa198>0</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>
<span style=color:#2aa198>1</span>) <span style=color:#2aa198>&#34;java cookbook&#34;</span>
<span style=color:#2aa198>2</span>) <span style=color:#2aa198>&#34;think in java&#34;</span></code></pre></div><h3 id=数据结构>数据结构</h3><p>众所周知, <code>Zset</code> 是一个有序的set集合, <code>redis</code> 通过 <code>hash table</code> 来存储 value 和 score 的映射关系,可以达到 <code>O(1)</code>, 通过 score 排序或者说按照 score 范围来获取这个区间的 value, 则是通过 <strong>跳表</strong> 来实现的. <code>Zset</code> 可以达到 <code>O(log(N))</code> 的插入和读写.</p><h4 id=什么是跳跃列表>什么是跳跃列表?</h4><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191102201627.png alt=skiplist></p><p>如图,跳跃列表是指具有纵向高度的有序链表.跳表会随机的某提升些链表的高度,并将每一层的节点进行连接,相当于构建<code>多级索引</code>,这样在查找的时候,从最高层开始查,可以过滤掉一大部分的范围,有点类似于二分查找.跳表也是典型的<code>空间换时间</code>的方式.</p><p>每一个 kv 块对应的结构如下面的代码中的<code>zslnode</code>结构,kv header 也是这个结构,只不过 value 字段是 null 值——无效的,score 是 <code>Double.MIN_VALUE</code>,用来垫底的。</p><h4 id=struct-1>struct</h4><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>struct</span> zslnode {
  string value;
  <span style=color:#dc322f>double</span> score;
  zslnode<span style=color:#719e07>*</span>[] forwards;  <span style=color:#586e75>// 多层连接指针
</span><span style=color:#586e75></span>  zslnode<span style=color:#719e07>*</span> backward;  <span style=color:#586e75>// 回溯指针
</span><span style=color:#586e75></span>}

<span style=color:#719e07>struct</span> zsl {
  zslnode<span style=color:#719e07>*</span> header; <span style=color:#586e75>// 跳跃列表头指针
</span><span style=color:#586e75></span>  <span style=color:#dc322f>int</span> maxLevel; <span style=color:#586e75>// 跳跃列表当前的最高层
</span><span style=color:#586e75></span>  map<span style=color:#719e07>&lt;</span>string, zslnode<span style=color:#719e07>*&gt;</span> ht; <span style=color:#586e75>// hash 结构的所有键值对
</span><span style=color:#586e75></span>}</code></pre></div><h4 id=redis中跳表的优化>redis中跳表的优化</h4><ol><li>允许 score 是重复的</li><li>比较不仅是通过 key(即 score), 也还会比较 data</li><li>最底层(<code>Level 1</code>)是有反向指针的,所以是一个双向链表,这样适用于从大到小的排序需求(<code>ZREVRANGE</code>)</li></ol><h4 id=一次查找的过程>一次查找的过程</h4><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191102202313.png alt=lookup-order></p><h4 id=redis中level是如何生成的>redis中level是如何生成的?</h4><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#586e75>/* Returns a random level for the new skiplist node we are going to create.
</span><span style=color:#586e75> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
</span><span style=color:#586e75> * (both inclusive), with a powerlaw-alike distribution where higher
</span><span style=color:#586e75> * levels are less likely to be returned. */</span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>zslRandomLevel</span>(<span style=color:#dc322f>void</span>) {
    <span style=color:#dc322f>int</span> level <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
    <span style=color:#719e07>while</span> ((random()<span style=color:#719e07>&amp;</span><span style=color:#2aa198>0xFFFF</span>) <span style=color:#719e07>&lt;</span> (ZSKIPLIST_P <span style=color:#719e07>*</span> <span style=color:#2aa198>0xFFFF</span>))
        level <span style=color:#719e07>+=</span> <span style=color:#2aa198>1</span>;
    <span style=color:#719e07>return</span> (level<span style=color:#719e07>&lt;</span>ZSKIPLIST_MAXLEVEL) <span style=color:#719e07>?</span> level : ZSKIPLIST_MAXLEVEL; 
}</code></pre></div><p><code>ZSKIPLIST_MAXLEVEL</code> 最大值是 <code>64</code>, 也就是最多 64 层.<code>ZSKIPLIST_P</code> 为 <code>1/4</code>, 也就是说有 25% 的概率有机会获得level,要获得更高的level,概率更小. 这也就导致了, redis中的跳表层级不会特别高,较扁平,较低层节点较多.有个小优化的地方: 跳表会记录下当前的最高层数 <code>MaxLevel</code> 这样就不需要从最顶层开始遍历了.</p><h4 id=为什么使用跳表而不是红黑树或者哈希表>为什么使用跳表而不是红黑树或者哈希表?</h4><ul><li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li><li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li><li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li><li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li><li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li><li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li></ul><h2 id=参考>参考</h2><ol><li><a href=https://luoming1224.github.io/2018/11/12/[redis学习笔记]redis渐进式rehash机制/>渐进式 rehash 机制</a></li><li><a href=https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html>美团针对Redis Rehash机制的探索和实践</a></li><li><a href=https://zsr.github.io/2017/07/03/redis-zset内部实现/>zset内部实现</a></li></ol></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/tags/redis>redis</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84>数据结构</a></li></ul></nav></div><script src=https://utteranc.es/client.js repo=xiaoheiAh/xiaoheiAh.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div>© Copyright notice | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>