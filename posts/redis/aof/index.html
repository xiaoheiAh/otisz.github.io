<!doctype html><html><head lang=zh><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Redis-AOF持久化 - xiaoheiAh's blog</title><link rel=icon type=image/png href=https://blog.xiaohei.im/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Redis-AOF持久化"><meta property="og:description" content="「Redis 学习笔记」| 持久化机制 | AOF"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.xiaohei.im/posts/redis/aof/"><meta property="article:published_time" content="2019-11-08T15:18:05+08:00"><meta property="article:modified_time" content="2019-11-08T15:18:05+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis-AOF持久化"><meta name=twitter:description content="「Redis 学习笔记」| 持久化机制 | AOF"><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/main.css><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/custom.css><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/dark.css media="(prefers-color-scheme: dark)"><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/custom-dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://blog.xiaohei.im/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://blog.xiaohei.im/>xiaoheiAh's blog</a></h1><div class=site-description><h2>Java Developer | 日常逛逛v站, 刷 github</h2><nav class="nav social"><ul class=flat><a href=https://github.com/xiaoheiAh title=xiaoheiAh><i data-feather=github></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/awesome>Awesome</a></li><li><a href=/cheatsheet>CheatSheet</a></li><li><a href=/about>About</a></li></ul></nav></div><div class=post-header><h1 class=title>Redis-AOF持久化</h1><div class=meta>Posted at &mdash; Nov 8, 2019</div><div class=meta></div></div><div class=markdown><p><code>RDB</code> 和 <code>AOF</code> 区别在于: 前者保存数据库快照,持久化所有键值对,后者通过保存 <strong>写命令</strong> 保证数据库的状态.</p><h2 id=什么是-aof->什么是 AOF ?</h2><p><code>AOF</code> 持久化通过保存服务器执行的写命令实现,进行恢复时通过重放 <code>AOF</code> 文件中的写命令,来保证数据安全.就像 <code>mysql</code> 的 <code>binlog</code> 一样.</p><h3 id=开启-aof>开启 AOF</h3><p>通过在 <code>redis.conf</code> 中将 <code>appendonly</code> 设为 <code>yes</code> 即可</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#586e75># redis.conf</span>
appendonly yes
<span style=color:#586e75># 设置 aof 文件名字</span>
appendfilename <span style=color:#2aa198>&#34;appendonly.aof&#34;</span>
<span style=color:#586e75># Redis支持三种不同的刷写模式：</span>
<span style=color:#586e75># appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。</span>
appendfsync everysec <span style=color:#586e75>#每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。</span>
<span style=color:#586e75># appendfsync no     #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。</span>
</code></pre></div><h3 id=aof-文件格式>AOF 文件格式</h3><p><code>AOF</code> 文件格式以 <code>redis</code> 命令请求协议为标准的,<code>*.aof</code> 文件可以直接打开.</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191112184639.png alt=redis设计与实现-aof格式></p><h3 id=aof-持久化过程>AOF 持久化过程</h3><h4 id=命令追加-append>命令追加 append</h4><p><code>redis</code> 执行完客户端的写命令后,会将该命令以协议的格式写入到 <code>aof_buf</code> 中.该属性为 <code>redisServer</code> 中的一个.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>#src/server.h
</span><span style=color:#719e07></span><span style=color:#719e07>struct</span> redisServer {
 ....
 sds aof_buf;      <span style=color:#586e75>/* AOF buffer, written before entering the event loop */</span>
}
</code></pre></div><h4 id=aof-写入同步>AOF 写入同步</h4><p><code>redis</code> 的服务进程是一个 <strong>事件循环</strong> - <code>event loop</code> , 每次循环大概会做三件事.</p><ol><li>文件事件: 接收客户端的命令,返回结果</li><li>时间事件: 执行系统的定时任务(<code>serverCron</code>), 完成渐进 <code>rehash</code> 扩容之类的操作</li><li>aof flush: 是否将 <code>aof_buf</code> 中的内容写入文件中</li></ol><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#586e75># 伪代码</span>
def eventloop<span style=color:#719e07>()</span>:
 <span style=color:#719e07>while</span> true:
 	processFileEvents<span style=color:#719e07>()</span> <span style=color:#586e75># 处理命令</span>
 	processTimeEvents<span style=color:#719e07>()</span> <span style=color:#586e75># 处理定时任务</span>
 	flushAppendOnlyFile<span style=color:#719e07>()</span> <span style=color:#586e75># 处理 aof 写入</span>
 	
</code></pre></div><p><code>flushAppendOnlyFile</code> 中的动作是否执行是根据一个配置决定的.</p><h5 id=appendfsync>appendfsync</h5><p>该配置有几个值可选,默认是 <code>everysec</code>.</p><ol><li>always: 总是写入.只要程序执行到这一步了,就将 <code>aof_buf</code> 中命令协议写入到文件</li><li>everysec: 每秒写入. 每次执行前会先判断是否与上次写入间隔一秒,再次同步时通过 <strong>一个线程</strong> 专门执行</li><li>no: 不写入. 命令写入 <code>aof_buf</code> 后由操作系统决定何时同步到文件</li></ol><blockquote><p>fsync: 现代操作系统为了提高文件读写的效率,通常会将 <code>write</code> 函数写入的数据缓存在内存中,等到缓存空间填满或者超过一定时限,再将其写入磁盘.这样的问题在于宕机时缓存中的数据就无法恢复.所以操作系统提供了 <strong>fsync/fdatasync</strong> 两个函数,强制操作系统将数据立即写入磁盘,保证数据安全.两函数区别在于: 前者会更新文件的属性,后者只更新数据.</p></blockquote><p>三种模式在性能和数据上都有相对的优缺点. <code>always</code> 模式数据安全性更强,毕竟每次都是直接写入,但是就会影响性能.磁盘读写是比较慢的. <code>everysec</code> 模式性能较好,但会丢失一秒内的缓存数据. <code>no</code> 模式就完全取决于操作系统了.</p><h4 id=aof-还原数据>AOF 还原数据</h4><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191113182005.png alt=redis设计与实现-aof还原数据></p><h3 id=aof-重写>AOF 重写</h3><p><code>AOF</code> 重写的意思其实就是对单个命令的多个操作进行整理,留下最终态的执行命令来减少 <code>aof</code> 文件的大小.你可以想象一下执行 1w 次 <code>incr</code> 操作,写入 <code>aof</code> 1w 次的场景.</p><h4 id=触发条件>触发条件</h4><p><code>AOF</code> 重写可以自动触发.通过配置 <code>auto-aof-rewrite-min-size</code> 和<code>auto-aof-rewrite-percentage</code>,满足条件就会自动重写.具体可以查看官方的 <code>redis.conf</code></p><h4 id=重写过程>重写过程</h4><ol><li>创建子进程，根据内存里的数据重写<code>aof</code>，保存到<code>temp</code>文件</li><li>此时主进程还会接收命令，会将写操作追加到旧的<code>aof</code>文件中，并保存在<code>server.aof_rewrite_buf_blocks</code>中，通过管道发送给子进程存在<code>server.aof_child_diff</code>中，最后追加到<code>temp</code>文件结尾</li><li>子进程重写完成后退出，主进程根据子进程退出状态，判断成功与否。成功就将剩余的<code>server.aof_rewrite_buf_blocks</code>追加到<code>temp file</code>中，然后<code>rename()</code>覆盖原<code>aof</code>文件</li></ol><p>重写的过程中主进程还是会一直接受客户端的命令,所以重写子进程与主进程肯定会存在数据不一致的情况.<code>redis</code>针对这种情况作出了解决方案: 新增一个 <code>aof_rewrite_buf_blocks</code>, <code>aof</code> 写入命令时,不仅写入到 <code>aof_buf</code>, 如果正在重写,那么也写入到 <code>aof_rewrite_buf_blocks</code> 中,这样在子进程重写完毕后,可以将 <code>aof_rewrite_buf_blocks</code> 的命令追加到新文件中,保证数据不丢失.</p><p><code>rename</code> 操作是原子的,也是唯一会造成主进程阻塞的操作.</p><h2 id=参考>参考</h2><ol><li><a href=https://redis.io/topics/persistence>https://redis.io/topics/persistence</a></li><li><a href=https://youjiali1995.github.io/redis/persistence/>https://youjiali1995.github.io/redis/persistence/</a></li></ol></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/tags/redis>redis</a></li></ul></nav></div><script src=https://utteranc.es/client.js repo=xiaoheiAh/xiaoheiAh.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div>© Copyright notice | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>