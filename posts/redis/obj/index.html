<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Redis-万物皆「对象」 - xiaoheiAh's blog</title><link rel=icon type=image/png href=https://blog.xiaohei.im/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Redis-万物皆「对象」"><meta property="og:description" content="「Redis 学习笔记」| redis 对象 | object | 结构定义"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.xiaohei.im/posts/redis/obj/"><meta property="article:published_time" content="2019-11-04T18:56:15+08:00"><meta property="article:modified_time" content="2019-11-04T18:56:15+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis-万物皆「对象」"><meta name=twitter:description content="「Redis 学习笔记」| redis 对象 | object | 结构定义"><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/main.css><link rel=stylesheet href="https://fonts.loli.net/css2?display=swap&family=Bitter&family=Noto+Sans+SC"><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://blog.xiaohei.im/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://blog.xiaohei.im/>xiaoheiAh's blog</a></h1><div class=site-description><h2>Java Developer | 关注后端</h2><nav class="nav social"><ul class=flat><a href=https://github.com/xiaoheiAh title=xiaoheiAh><i data-feather=github></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/awesome>Awesome</a></li><li><a href=/cheatsheet>CheatSheet</a></li><li><a href=/about>About</a></li></ul></nav></div><div class=post-header><h1 class=title>Redis-万物皆「对象」</h1><div class=meta style=display:inline>Posted at &mdash; Nov 4, 2019</div><div class=meta style=display:inline><a>Page Views: 3</a></div></div><div class=markdown><p>Redis有很多种数据结构,但其并没有直接使用这些数据结构来构建这个 <code>NOSQL</code>, 而是通过 <code>对象系统</code> 完成了对所有数据结构的统一管理, 实现内存回收, 对象共享等特性~</p><h2 id=类型及编码>类型及编码</h2><p>在 <code>Redis</code> 中使用任何命令操作,都是操作的一个对象.有键对象,值对象.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b58900>set</span> msg <span style=color:#2aa198>&#34;hello~&#34;</span> <span style=color:#586e75># msg 为键对象, &#34;hello~&#34; 为值对象</span>
</code></pre></div><p>每个对象都会有如下的结构:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> redisObject {
    <span style=color:#dc322f>unsigned</span> type:<span style=color:#2aa198>4</span>; <span style=color:#586e75>// 类型
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> encoding:<span style=color:#2aa198>4</span>; <span style=color:#586e75>// 编码
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> lru:LRU_BITS; <span style=color:#586e75>/* LRU time (relative to global lru_clock) or
</span><span style=color:#586e75>                            * LFU data (least significant 8 bits frequency
</span><span style=color:#586e75>                            * and most significant 16 bits access time). */</span>
    <span style=color:#dc322f>int</span> refcount; <span style=color:#586e75>// 引用计数
</span><span style=color:#586e75></span>    <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>ptr; <span style=color:#586e75>// 指向底层实现数据结构的指针
</span><span style=color:#586e75></span>} robj;
</code></pre></div><h3 id=type-类型>type 类型</h3><p><code>type</code> 指明了该对象的类型. <code>redis</code> 中类型有如下几种</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#586e75>/* The actual Redis Object */</span>
<span style=color:#719e07>#define OBJ_STRING 0    </span><span style=color:#586e75>/* String object. */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_LIST 1      </span><span style=color:#586e75>/* List object. */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_SET 2       </span><span style=color:#586e75>/* Set object. */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ZSET 3      </span><span style=color:#586e75>/* Sorted set object. */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_HASH 4      </span><span style=color:#586e75>/* Hash object. */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_MODULE 5    </span><span style=color:#586e75>/* Module object. */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_STREAM 6    </span><span style=color:#586e75>/* Stream object. */</span><span style=color:#719e07>
</span></code></pre></div><p><code>redis</code> 中键都为字符串对象,利用 <code>type</code> 命令可以查看值对象的类型</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>reids&gt; <span style=color:#b58900>type</span> language
list
</code></pre></div><h3 id=encoding-编码>encoding 编码</h3><p><code>encoding</code> 属性记录了该对象使用的什么数据结构存储底层的实现,即 <code>*ptr</code> 所指向的那个数据结构.以下是目前的编码类型.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#586e75>/* Objects encoding. Some kind of objects like Strings and Hashes can be
</span><span style=color:#586e75> * internally represented in multiple ways. The &#39;encoding&#39; field of the object
</span><span style=color:#586e75> * is set to one of this fields for this object. */</span>
<span style=color:#719e07>#define OBJ_ENCODING_RAW 0     </span><span style=color:#586e75>/* Raw representation */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_INT 1     </span><span style=color:#586e75>/* Encoded as integer */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_HT 2      </span><span style=color:#586e75>/* Encoded as hash table */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_ZIPMAP 3  </span><span style=color:#586e75>/* Encoded as zipmap */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_ZIPLIST 5 </span><span style=color:#586e75>/* Encoded as ziplist */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_INTSET 6  </span><span style=color:#586e75>/* Encoded as intset */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_SKIPLIST 7  </span><span style=color:#586e75>/* Encoded as skiplist */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_EMBSTR 8  </span><span style=color:#586e75>/* Embedded sds string encoding */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_QUICKLIST 9 </span><span style=color:#586e75>/* Encoded as linked list of ziplists */</span><span style=color:#719e07>
</span><span style=color:#719e07>#define OBJ_ENCODING_STREAM 10 </span><span style=color:#586e75>/* Encoded as a radix tree of listpacks */</span><span style=color:#719e07>
</span></code></pre></div><p>基本上每种类型的对象都会对应两种编码类型,可以动态的根据用户输入的值提供最有的数据结构,减少资源消耗.</p><h2 id=字符串对象>字符串对象</h2><p>字符串对象有三种编码格式. <code>int</code>,<code>embstr</code>,<code>raw</code>,不同长度不同格式有不一样的编码类型.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>47.100.254.74:6379&gt; <span style=color:#b58900>set</span> msg <span style=color:#2aa198>&#34;abcdefg&#34;</span>
OK
<span style=color:#719e07>(</span>0.53s<span style=color:#719e07>)</span>
47.100.254.74:6379&gt; object encoding msg
<span style=color:#2aa198>&#34;embstr&#34;</span>
47.100.254.74:6379&gt; <span style=color:#b58900>set</span> msg <span style=color:#2aa198>&#34;abcdefghijklmnopqrstuvwxyz01234567890123456789&#34;</span>
OK
47.100.254.74:6379&gt; object encoding msg
<span style=color:#2aa198>&#34;raw&#34;</span>
47.100.254.74:6379&gt; <span style=color:#b58900>set</span> msg <span style=color:#2aa198>123</span>
OK
47.100.254.74:6379&gt; object encoding msg
<span style=color:#2aa198>&#34;int&#34;</span>
</code></pre></div><h3 id=embstr-vs-raw>embstr vs raw</h3><p>一个字符串对象包括 <code>redisObject</code> 和 <code>sds</code> 两部分组成.正常情况下是需要分配两次内存来创建这两个结构.这也是<code>raw</code> 的格式,但是如果当 <code>value</code> 长度较短时, (由于 <code>redis</code> 使用的是 <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> 分配内存)我们可以将内存分配控制在一次,将 <code>RedisObject</code> 和 <code>sds</code> 分配在连续的内存空间,这也就是 <code>embstr</code> 编码格式了.那多短算短呢?</p><p>在此之前先了解下创建一个 <code>redisObject</code> 时所占用的空间.</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191105112554.png alt=redis-obj-malloc></p><p><code>embstr</code>编码是由 代表着 字符串的数据结构是 <code>SDS</code>.假设为 <code>sdshdr8</code></p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>struct</span> sdshdr8 {
    uint8_t len; <span style=color:#586e75>/* 1byte used */</span>
    uint8_t alloc; <span style=color:#586e75>/* 1byte excluding the header and null terminator */</span>
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> flags; <span style=color:#586e75>/* 1byte 3 lsb of type, 5 unused bits */</span>
    <span style=color:#dc322f>char</span> buf[];
};
</code></pre></div><p><code>jemalloc</code> 可以分配 8/16/32/64 字节大小的内存,从上可以发现最少的内存需要占用 19 字节, Redis 在总体大于 64 字节时,会改为 <code>raw</code> 存储. 所以 <code>embstr</code> 形式时最大长度是 <code>64 - 19 - 结束符\0长度 = 44</code></p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191105121309.png alt=embstr></p><h3 id=编码转换>编码转换</h3><p>由于 <code>redis</code> 没有为 <code>embstr</code> 编写修改相关的程序,所以是只读的, 如果对其执行任何修改命令,就会变为 <code>raw</code> 格式.</p><h2 id=类型检查>类型检查</h2><p><code>redis</code> 中的操作命令一般有两种: 所有类型都能用的(<code>DEL</code>, <code>EXPIRE</code>&mldr;), 特定类型适用的(各种数据类型对应的命令).若操作键的命令不对, <code>redis</code> 会提示报错.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>47.100.254.74:6379&gt; <span style=color:#b58900>set</span> numbers <span style=color:#2aa198>1</span>
OK
47.100.254.74:6379&gt; object encoding numbers
<span style=color:#2aa198>&#34;int&#34;</span>
47.100.254.74:6379&gt; rpush numbers a
<span style=color:#719e07>(</span>error<span style=color:#719e07>)</span> WRONGTYPE Operation against a key holding the wrong kind of value
</code></pre></div><h3 id=如何实现>如何实现?</h3><p>利用 <code>RedisObject</code> 的<code>type</code> 来控制.在输入一个命令时, 服务器会先检查输入键所对应的的值对象是否为命令对应的类型,是的话就执行,不是就报错.</p><h2 id=多态命令>多态命令</h2><p>同一种数据结构可能有多种编码格式.比如字符串对象的编码格式可能有 <code>int</code>, <code>embstr</code>, <code>raw</code>.所以当命令执行前,还需要根据值对象的编码来选择正确的命令来实现.</p><p>比如想要执行 <code>llen</code> 获取 list 长度, 如果编码为 <code>ziplist</code>, 那么程序就会使用 <code>ziplist</code> 对应的函数来计算, 编码为 <code>quicklist</code> 时则是使用 <code>quicklist</code> 对应的函数来计算. 此为命令的 <strong>多态</strong> .</p><h2 id=内存回收>内存回收</h2><p><code>redis</code> 利用引用计数来实现内存回收机制.由 <code>RedisObject</code> 中的 <code>refcount</code> 属性记录.</p><p>引用计数是有导致循环引用的弊端的,那么redis为啥还是会用的?找了很久也没有找到答案.</p><p>有一个说法是: 引用的复杂度很低,不太容易导致循环引用.就一切从简呗.</p><h2 id=对象共享>对象共享</h2><p>对象共享指的是创建一次对象后,后面如果还有客户端需要创建同样的值对象则直接把现在这个的引用只给他,引用计数加1,可以节省内存的开销.类似 Java 常量池. 所以<code>refcount</code> 也被用来做对象共享的.</p><p><code>redis</code> 在初始化服务器时, 会创建 0 - 9999 一万个整数字符串, 为了节省资源.</p><h3 id=为什么不共享其他的复杂对象>为什么不共享其他的复杂对象?</h3><ol><li>整数复用几率很大</li><li>整数比较算法时间复杂度是 O(1), 字符串是 O(N), hash/list 复杂度是 O(n2)</li></ol><h2 id=键的空转时长>键的空转时长</h2><p><code>redisObject</code> 的 <code>lru</code> 属性记录着该对象最后一次被命令程序访问的时间.该属性在内存回收中有很大的作用.</p><p>空转时长指的是<code> now() - lru</code></p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>47.100.254.74:6379&gt; object idletime numbers
<span style=color:#719e07>(</span>integer<span style=color:#719e07>)</span> <span style=color:#2aa198>4023</span>
</code></pre></div></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/tags/redis>redis</a></li></ul></nav></div><script src=https://utteranc.es/client.js repo=xiaoheiAh/xiaoheiAh.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div class=badge><img src=https://img.shields.io/badge/PV-6188-green alt=pv>
<img src=https://img.shields.io/badge/UV-1747-green alt=uv>
<img src="https://img.shields.io/badge/License-CC%20BY%20NC%20ND%204.0-green?link=http://creativecommons.org/licenses/by-nc-nd/4.0/" alt="CC BY NC ND 4.0">
<span>| © 2019 | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></span></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>