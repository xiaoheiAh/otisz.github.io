<!doctype html><html><head lang=zh><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>[学习笔记] Netty - xiaoheiAh's blog</title><link rel=icon type=image/png href=https://blog.xiaohei.im/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="[学习笔记] Netty"><meta property="og:description" content="「Netty 学习笔记」"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.xiaohei.im/posts/netty/"><meta property="article:published_time" content="2019-11-29T18:40:27+08:00"><meta property="article:modified_time" content="2019-11-29T18:40:27+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[学习笔记] Netty"><meta name=twitter:description content="「Netty 学习笔记」"><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/main.css><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/custom.css><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/dark.css media="(prefers-color-scheme: dark)"><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/custom-dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://blog.xiaohei.im/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://blog.xiaohei.im/>xiaoheiAh's blog</a></h1><div class=site-description><h2>Java Developer | 日常逛逛v站, 刷 github</h2><nav class="nav social"><ul class=flat><a href=https://github.com/xiaoheiAh title=xiaoheiAh><i data-feather=github></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/awesome>Awesome</a></li><li><a href=/cheatsheet>CheatSheet</a></li><li><a href=/about>About</a></li></ul></nav></div><div class=post-header><h1 class=title>[学习笔记] Netty</h1><div class=meta>Posted at &mdash; Nov 29, 2019</div><div class=meta></div></div><div class=markdown><blockquote><p>Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。</p></blockquote><p><strong>NIO:</strong> selector 模型,用一个线程监听多个连接的读写请求,减少线程资源的浪费.</p><h3 id=netty-优点>netty 优点</h3><ol><li>使用 JDK 自带的NIO需要了解太多的概念，编程复杂，一不小心 bug 横飞</li><li>Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从 NIO 模型变身为 IO 模型</li><li>Netty 自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</li><li>Netty 解决了 JDK 的很多包括空轮询在内的 Bug</li><li>Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理</li><li>自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</li><li>Netty 社区活跃，遇到问题随时邮件列表或者 issue</li><li>Netty 已经历各大 RPC 框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大</li></ol><h3 id=server端>Server端</h3><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#586e75>// 负责服务端的启动
</span><span style=color:#586e75></span>ServerBootstrap serverBootstrap <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ServerBootstrap<span style=color:#719e07>();</span>
<span style=color:#586e75>// 负责接收新连接
</span><span style=color:#586e75></span>NioEventLoopGroup boss <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> NioEventLoopGroup<span style=color:#719e07>();</span>
<span style=color:#586e75>// 负责读取数据及业务逻辑处理
</span><span style=color:#586e75></span>NioEventLoopGroup worker <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> NioEventLoopGroup<span style=color:#719e07>();</span>

serverBootstrap<span style=color:#719e07>.</span>group<span style=color:#719e07>(</span>boss<span style=color:#719e07>,</span> worker<span style=color:#719e07>)</span>
  <span style=color:#586e75>// 指定服务端 IO 模型为 NIO
</span><span style=color:#586e75></span>  <span style=color:#719e07>.</span>channel<span style=color:#719e07>(</span>NioServerSocketChannel<span style=color:#719e07>.</span>class<span style=color:#719e07>)</span>
  <span style=color:#586e75>// 业务逻辑处理
</span><span style=color:#586e75></span>  <span style=color:#719e07>.</span>childHandler<span style=color:#719e07>(</span><span style=color:#719e07>new</span> ChannelInitializer<span style=color:#719e07>&lt;</span>NioSocketChannel<span style=color:#719e07>&gt;()</span> <span style=color:#719e07>{</span>
    <span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>initChannel</span><span style=color:#719e07>(</span>NioSocketChannel ch<span style=color:#719e07>)</span> <span style=color:#268bd2>throws</span> Exception <span style=color:#719e07>{</span>
      ch<span style=color:#719e07>.</span>pipeline<span style=color:#719e07>().</span>addLast<span style=color:#719e07>(</span><span style=color:#719e07>new</span> StringDecoder<span style=color:#719e07>());</span>
      ch<span style=color:#719e07>.</span>pipeline<span style=color:#719e07>().</span>addLast<span style=color:#719e07>(</span><span style=color:#719e07>new</span> SimpleChannelInboundHandler<span style=color:#719e07>&lt;</span>String<span style=color:#719e07>&gt;()</span> <span style=color:#719e07>{</span>
        <span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>channelRead0</span><span style=color:#719e07>(</span>ChannelHandlerContext channelHandlerContext<span style=color:#719e07>,</span> String s<span style=color:#719e07>)</span> <span style=color:#268bd2>throws</span> Exception <span style=color:#719e07>{</span>
          System<span style=color:#719e07>.</span>out<span style=color:#719e07>.</span>println<span style=color:#719e07>(</span>s<span style=color:#719e07>);</span>
        <span style=color:#719e07>}</span>
      <span style=color:#719e07>});</span>
    <span style=color:#719e07>}</span>
  <span style=color:#719e07>})</span>
  <span style=color:#719e07>.</span>bind<span style=color:#719e07>(</span>8000<span style=color:#719e07>);</span>
</code></pre></div><ul><li><strong>NioSocketChannel/NioServerSocketChannel</strong> Netty 对 NIO 类型连接的抽象</li></ul><h4 id=handler--childhandler>handler() & childHandler()</h4><ul><li>handler() 用于指定服务器端在启动过程中的一些逻辑</li><li>childHandler() 用于指定处理新连接数据的读写逻辑</li></ul><h4 id=attr--childattr>attr() & childAttr()</h4><p>分别可以给服务端连接,客户端连接指定相应的属性,后续通过 <code>channel.attr()</code> 可以拿到.</p><h4 id=option--childoption>option() & childOption()</h4><ul><li><p>option() 用于给服务端连接设定一系列的属性,最常见的是 <code>so_backlog</code></p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#586e75>// 表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数
</span><span style=color:#586e75></span>serverBootstrap<span style=color:#719e07>.</span>option<span style=color:#719e07>(</span>ChannelOption<span style=color:#719e07>.</span>SO_BACKLOG<span style=color:#719e07>,</span> 1024<span style=color:#719e07>)</span>
</code></pre></div></li><li><p>childOption() 给每条连接设置一些属性</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>serverBootstrap
              <span style=color:#586e75>// 是否开启TCP底层心跳机制，true为开启
</span><span style=color:#586e75></span>        <span style=color:#719e07>.</span>childOption<span style=color:#719e07>(</span>ChannelOption<span style=color:#719e07>.</span>SO_KEEPALIVE<span style=color:#719e07>,</span> <span style=color:#cb4b16>true</span><span style=color:#719e07>)</span>
              <span style=color:#586e75>// 是否开启Nagle算法，true表示关闭，false表示开启，通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。
</span><span style=color:#586e75></span>        <span style=color:#719e07>.</span>childOption<span style=color:#719e07>(</span>ChannelOption<span style=color:#719e07>.</span>TCP_NODELAY<span style=color:#719e07>,</span> <span style=color:#cb4b16>true</span><span style=color:#719e07>)</span>
</code></pre></div></li></ul><h3 id=client端>Client端</h3><p>带连接失败重试的客户端,失败重试延迟为 2 的幂次.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#586e75>// 客户端启动
</span><span style=color:#586e75></span>Bootstrap bootstrap <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Bootstrap<span style=color:#719e07>();</span>
<span style=color:#586e75>// 线程模型
</span><span style=color:#586e75></span>NioEventLoopGroup group <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> NioEventLoopGroup<span style=color:#719e07>();</span>

bootstrap<span style=color:#719e07>.</span>group<span style=color:#719e07>(</span>group<span style=color:#719e07>)</span>
  <span style=color:#586e75>// 指定 IO 模型为 NIO
</span><span style=color:#586e75></span>  <span style=color:#719e07>.</span>channel<span style=color:#719e07>(</span>NioSocketChannel<span style=color:#719e07>.</span>class<span style=color:#719e07>)</span>
  <span style=color:#586e75>// 业务逻辑处理
</span><span style=color:#586e75></span>  <span style=color:#719e07>.</span>handler<span style=color:#719e07>(</span><span style=color:#719e07>new</span> ChannelInitializer<span style=color:#719e07>&lt;</span>Channel<span style=color:#719e07>&gt;()</span> <span style=color:#719e07>{</span>
    <span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>initChannel</span><span style=color:#719e07>(</span>Channel ch<span style=color:#719e07>)</span> <span style=color:#268bd2>throws</span> Exception <span style=color:#719e07>{</span>
      ch<span style=color:#719e07>.</span>pipeline<span style=color:#719e07>().</span>addLast<span style=color:#719e07>(</span><span style=color:#719e07>new</span> StringEncoder<span style=color:#719e07>());</span>
    <span style=color:#719e07>}</span>
  <span style=color:#719e07>});</span>
connect<span style=color:#719e07>(</span>bootstrap<span style=color:#719e07>,</span><span style=color:#2aa198>&#34;127.0.0.1&#34;</span><span style=color:#719e07>,</span> 8000<span style=color:#719e07>,</span> MAX_RETRY<span style=color:#719e07>);</span>

<span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>connect</span><span style=color:#719e07>(</span>Bootstrap bootstrap<span style=color:#719e07>,</span> String host<span style=color:#719e07>,</span> <span style=color:#dc322f>int</span> port<span style=color:#719e07>,</span> <span style=color:#dc322f>int</span> retry<span style=color:#719e07>)</span> <span style=color:#719e07>{</span>
    bootstrap<span style=color:#719e07>.</span>connect<span style=color:#719e07>(</span>host<span style=color:#719e07>,</span> port<span style=color:#719e07>).</span>addListener<span style=color:#719e07>(</span>future <span style=color:#719e07>-&gt;</span> <span style=color:#719e07>{</span>
        <span style=color:#719e07>if</span> <span style=color:#719e07>(</span>future<span style=color:#719e07>.</span>isSuccess<span style=color:#719e07>())</span> <span style=color:#719e07>{</span>
            System<span style=color:#719e07>.</span>out<span style=color:#719e07>.</span>println<span style=color:#719e07>(</span><span style=color:#2aa198>&#34;连接成功!&#34;</span><span style=color:#719e07>);</span>
        <span style=color:#719e07>}</span> <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> <span style=color:#719e07>(</span>retry <span style=color:#719e07>==</span> 0<span style=color:#719e07>)</span> <span style=color:#719e07>{</span>
            System<span style=color:#719e07>.</span>err<span style=color:#719e07>.</span>println<span style=color:#719e07>(</span><span style=color:#2aa198>&#34;重试次数已用完，放弃连接！&#34;</span><span style=color:#719e07>);</span>
        <span style=color:#719e07>}</span> <span style=color:#719e07>else</span> <span style=color:#719e07>{</span>
            <span style=color:#586e75>// 第几次重连
</span><span style=color:#586e75></span>            <span style=color:#dc322f>int</span> order <span style=color:#719e07>=</span> <span style=color:#719e07>(</span>MAX_RETRY <span style=color:#719e07>-</span> retry<span style=color:#719e07>)</span> <span style=color:#719e07>+</span> 1<span style=color:#719e07>;</span>
            <span style=color:#586e75>// 本次重连的间隔
</span><span style=color:#586e75></span>            <span style=color:#dc322f>int</span> delay <span style=color:#719e07>=</span> 1 <span style=color:#719e07>&lt;&lt;</span> order<span style=color:#719e07>;</span>
            System<span style=color:#719e07>.</span>err<span style=color:#719e07>.</span>println<span style=color:#719e07>(</span><span style=color:#719e07>new</span> Date<span style=color:#719e07>()</span> <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;: 连接失败，第&#34;</span> <span style=color:#719e07>+</span> order <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;次重连……&#34;</span><span style=color:#719e07>);</span>
            bootstrap<span style=color:#719e07>.</span>config<span style=color:#719e07>().</span>group<span style=color:#719e07>().</span>schedule<span style=color:#719e07>(()</span> <span style=color:#719e07>-&gt;</span> connect<span style=color:#719e07>(</span>bootstrap<span style=color:#719e07>,</span> host<span style=color:#719e07>,</span> port<span style=color:#719e07>,</span> retry <span style=color:#719e07>-</span> 1<span style=color:#719e07>),</span> delay<span style=color:#719e07>,</span> TimeUnit
                    <span style=color:#719e07>.</span>SECONDS<span style=color:#719e07>);</span>
        <span style=color:#719e07>}</span>
    <span style=color:#719e07>});</span>
<span style=color:#719e07>}</span>
</code></pre></div><h4 id=其他方法>其他方法</h4><ul><li>attr() 客户端绑定属性</li><li>option() 设置客户端 TCP 连接</li></ul><h3 id=bytebuf>ByteBuf</h3><p>netty 中的数据都是以 <code>ByteBuf</code> 为单位的,所有需要写出的数据都必须塞到 <code>ByteBuf</code> 中.</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191202111539.png alt=ByteBuf-数据结构(掘金小册配图)></p><ol><li><code>ByteBuf</code> 是一个字节容器，容器里面的的数据分为三个部分，第一个部分是已经丢弃的字节，这部分数据是无效的；第二部分是可读字节，这部分数据是 <code>ByteBuf</code> 的主体数据， 从 <code>ByteBuf</code> 里面读取的数据都来自这一部分;最后一部分的数据是可写字节，所有写到 <code>ByteBuf</code> 的数据都会写到这一段。最后一部分虚线表示的是该 <code>ByteBuf</code> 最多还能扩容多少容量</li><li>以上三段内容是被两个指针给划分出来的，从左到右，依次是读指针（<code>readerIndex</code>）、写指针（<code>writerIndex</code>），然后还有一个变量 <code>capacity</code>，表示 <code>ByteBuf</code> 底层内存的总容量</li><li>从 ByteBuf 中每读取一个字节，<code>readerIndex</code> 自增1，<code>ByteBuf</code> 里面总共有 <code>writerIndex-readerIndex</code> 个字节可读, 由此可以推论出当 <code>readerIndex</code> 与 <code>writerIndex</code> 相等的时候，<code>ByteBuf</code> 不可读</li><li>写数据是从 <code>writerIndex</code> 指向的部分开始写，每写一个字节，<code>writerIndex</code> 自增1，直到增到 <code>capacity</code>，这个时候，表示 <code>ByteBuf</code> 已经不可写了</li><li><code>ByteBuf</code> 里面其实还有一个参数 <code>maxCapacity</code>，当向 <code>ByteBuf</code> 写数据的时候，如果容量不足，那么这个时候可以进行扩容，直到 <code>capacity</code> 扩容到 <code>maxCapacity</code>，超过 <code>maxCapacity</code> 就会报错</li></ol><h4 id=bytebuf-容量相关api>ByteBuf 容量相关API</h4><h5 id=capacity>capacity()</h5><p>表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式，后面我们讲 ByteBuf 的分类的时候会讲到</p><h5 id=maxcapacity>maxCapacity()</h5><p>表示 ByteBuf 底层最大能够占用多少字节的内存，当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity，超过这个数，就抛异常</p><h5 id=readablebytes-与-isreadable>readableBytes() 与 isReadable()</h5><p>readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</p><h5 id=writablebytes-iswritable-与-maxwritablebytes>writableBytes()、 isWritable() 与 maxWritableBytes()</h5><p>writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往 ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于 maxCapacity-writerIndex</p><h4 id=bytebuf-读写指针相关-api>ByteBuf 读写指针相关 API</h4><h5 id=readerindex-与-readerindexint>readerIndex() 与 readerIndex(int)</h5><p>前者表示返回当前的读指针 readerIndex, 后者表示设置读指针</p><h5 id=writeindex-与-writeindexint>writeIndex() 与 writeIndex(int)</h5><p>前者表示返回当前的写指针 writerIndex, 后者表示设置写指针</p><h5 id=markreaderindex-与-resetreaderindex>markReaderIndex() 与 resetReaderIndex()</h5><p>前者表示把当前的读指针保存起来，后者表示把当前的读指针恢复到之前保存的值</p><h5 id=markwriterindex-与-resetwriterindex>markWriterIndex() 与 resetWriterIndex()</h5><p>同上,但是针对写指针</p><h4 id=bytebuf-读写-api>ByteBuf 读写 API</h4><h5 id=writebytesbyte-src-与-bufferreadbytesbyte-dst>writeBytes(byte[] src) 与 buffer.readBytes(byte[] dst)</h5><p>writeBytes() 表示把字节数组 src 里面的数据全部写到 ByteBuf，而 readBytes() 指的是把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 readableBytes()，而 src 字节数组大小的长度通常小于等于 writableBytes()</p><h5 id=writebytebyte-b-与-bufferreadbyte>writeByte(byte b) 与 buffer.readByte()</h5><p>writeByte() 表示往 ByteBuf 中写一个字节，而 buffer.readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() 与 readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble()</p><p>与读写 API 类似的 API 还有 getBytes、getByte() 与 setBytes()、setByte() 系列，唯一的区别就是 get/set 不会改变读写指针，而 read/write 会改变读写指针，这点在解析数据的时候千万要注意</p><h5 id=release-与-retain>release() 与 retain()</h5><p>由于 Netty 使用了 <strong>堆外内存</strong>，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们<strong>手动回收</strong>。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 ByteBuf，它的引用为1，然后每次调用 retain() 方法， 它的引用就加一， release() 方法原理是将引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存。</p><h5 id=sliceduplicatecopy>slice()、duplicate()、copy()</h5><p>这三个方法通常情况会放到一起比较，这三者的返回值都是一个新的 ByteBuf 对象</p><ol><li>slice() 方法从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 readableBytes()</li><li>duplicate() 方法把整个 ByteBuf 都截取出来，包括所有的数据，指针信息</li><li>slice() 方法与 duplicate() 方法的相同点是：<strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 slice() 或者 duplicate() 返回的 ByteBuf 调用 write 系列方法都会影响到 原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针</li><li>slice() 方法与 duplicate() 不同点就是：slice() 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整个 ByteBuf 都与原始的 ByteBuf 共享</li><li>slice() 方法与 duplicate() 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为，而最后一个方法 copy() 会直接从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，因此，<strong>往 copy() 返回的 ByteBuf 中写数据不会影响到原始的 ByteBuf</strong></li><li>slice() 和 duplicate() 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 release() 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 retain() 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 release() 方法，将引用计数降到零，才会释放内存</li><li>这三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</li></ol><h3 id=pipeline--channelhandler>Pipeline & ChannelHandler</h3><p><code>pipeline</code> 的数据结构为 双向链表, 节点的类型是一个 <code>ChannelHandlerContext</code> 包含着 每一个 <code>channel</code> 的上下文信息, <code>contenxt</code> 中包裹着一个 <code>handler</code> 用于处理用户的逻辑,<code>pipeline</code> 利用 <strong>责任链</strong> 的模式执行完所有的 <code>handler</code>.</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191202194426.png alt=掘金小册-pipeline构成></p><h4 id=内置的-channelhandler>内置的 ChannelHandler</h4><ol><li><p><strong>ByteToMessageDecoder</strong></p><p>二进制 -> Java 对象转换,重写 <code>decode</code> 方法即可.默认情况下 <code>ByteBuf</code> 使用的是对外内存,通过引用计数判断是否需要清除.而该 <code>Decoder</code> 可以自动释放内存无需关心.</p></li><li><p><strong>SimpleChannelInboundHandler</strong></p><p>自动选择对应的消息进行处理,自动传递对象</p></li><li><p><strong>MessageToByteEncoder</strong></p><p>对象 -> 二进制</p></li></ol><h3 id=粘包--拆包>粘包 & 拆包</h3><blockquote><p><a href=https://www.cnblogs.com/wade-luffy/p/6165671.html>https://www.cnblogs.com/wade-luffy/p/6165671.html</a></p></blockquote><p>TCP 的传输是基于字节流的,没有明显的分界,有可能会把应用层的多个包合在一块发出去(<strong>粘包</strong>),有可能把一个过大的包分多次发出(<strong>拆包</strong>),粘包/拆包是相对的,一方拆包,一方就要粘包.</p><h4 id=tcp粘包拆包发生的原因>TCP粘包/拆包发生的原因</h4><p>问题产生的原因有三个，分别如下。</p><p>（1）应用程序write写入的字节大小大于套接口发送缓冲区大小；</p><p>（2）进行MSS大小的TCP分段；</p><p>（3）以太网帧的payload大于MTU进行IP分片。</p><h4 id=解决策略>解决策略</h4><p>通过应用层设计通用的结构保证.</p><ol><li>消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；</li><li>在包尾增加回车换行符进行分割，例如FTP协议；</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；</li><li>更复杂的应用层协议</li></ol><h4 id=netty-解决方案>netty 解决方案</h4><p>netty 提供了多种拆包器,满足用户的需求,不需要自己来对 <code>TCP</code> 流进行处理.</p><ol><li><p>固定长度拆包器 <strong>FixedLengthFrameDecoder</strong></p></li><li><p>行拆包器 <strong>LineBasedFrameDecoder</strong></p><p>数据包以换行符作为分隔.</p></li><li><p>分隔符拆包器 <strong>DelimiterBasedFrameDecoder</strong></p><p>行拆包器的通用版,自定义分隔符</p></li><li><p>基于长度域拆包器 <strong>LengthFieldBasedFrameDecoder</strong></p><p>自定义的协议中包含长度域字段,即可使用来拆包</p><blockquote><p>每次的包不是定长的,怎么就能通过位移确认长度域,进而确定长度?</p><p>答: 通过设置一个完整包的开始标志,确定是一个新包就可以了.比如通常会设置一个魔数,拆包前先判断是不是我们定义的包.然后再去通过位移定位到长度域.</p></blockquote></li></ol><h3 id=channelhandler-生命周期>ChannelHandler 生命周期</h3><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191203165854.png alt=生命周期图></p><ol><li><code>handlerAdded()</code> ：指的是当检测到新连接之后，调用 <code>ch.pipeline().addLast(new xxxHandler());</code> 之后的回调，表示在当前的 channel 中，已经成功添加了一个 handler 处理器。</li><li><code>channelRegistered()</code>：这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系，accept 到新的连接，然后创建一个线程来处理这条连接的读写，Netty 里面是使用了线程池的方式，只需要从线程池里面去抓一个线程绑定在这个 channel 上即可，这里的 NIO 线程通常指的是 <code>NioEventLoop</code>,不理解没关系，后面我们还会讲到。</li><li><code>channelActive()</code>：当 channel 的所有的业务逻辑链准备完毕（也就是说 channel 的 pipeline 中已经添加完所有的 handler）以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。</li><li><code>channelRead()</code>：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。</li><li><code>channelReadComplete()</code>：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。</li><li><code>channelInactive()</code>: 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 <strong>ESTABLISH</strong> 状态了</li><li><code>channelUnregistered()</code>: 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理</li><li><code>handlerRemoved()</code>：最后，我们给这条连接上添加的所有的业务逻辑处理器都给移除掉。</li></ol><h3 id=心跳--空闲检测>心跳 & 空闲检测</h3><h4 id=idlestatehandler>IdleStateHandler</h4><p>空闲检测(一段时间内是否有读写).</p><h4 id=实现一个心跳>实现一个心跳</h4><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeartBeatTimerHandler</span> <span style=color:#268bd2>extends</span> ChannelInboundHandlerAdapter <span style=color:#719e07>{</span>

    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>int</span> HEARTBEAT_INTERVAL <span style=color:#719e07>=</span> 5<span style=color:#719e07>;</span>

    <span style=color:#268bd2>@Override</span>
    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>channelActive</span><span style=color:#719e07>(</span>ChannelHandlerContext ctx<span style=color:#719e07>)</span> <span style=color:#268bd2>throws</span> Exception <span style=color:#719e07>{</span>
        scheduleSendHeartBeat<span style=color:#719e07>(</span>ctx<span style=color:#719e07>);</span>

        <span style=color:#268bd2>super</span><span style=color:#719e07>.</span>channelActive<span style=color:#719e07>(</span>ctx<span style=color:#719e07>);</span>
    <span style=color:#719e07>}</span>

    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>scheduleSendHeartBeat</span><span style=color:#719e07>(</span>ChannelHandlerContext ctx<span style=color:#719e07>)</span> <span style=color:#719e07>{</span>
        ctx<span style=color:#719e07>.</span>executor<span style=color:#719e07>().</span>schedule<span style=color:#719e07>(()</span> <span style=color:#719e07>-&gt;</span> <span style=color:#719e07>{</span>

            <span style=color:#719e07>if</span> <span style=color:#719e07>(</span>ctx<span style=color:#719e07>.</span>channel<span style=color:#719e07>().</span>isActive<span style=color:#719e07>())</span> <span style=color:#719e07>{</span>
                ctx<span style=color:#719e07>.</span>writeAndFlush<span style=color:#719e07>(</span><span style=color:#719e07>new</span> HeartBeatRequestPacket<span style=color:#719e07>());</span>
                scheduleSendHeartBeat<span style=color:#719e07>(</span>ctx<span style=color:#719e07>);</span>
            <span style=color:#719e07>}</span>

        <span style=color:#719e07>},</span> HEARTBEAT_INTERVAL<span style=color:#719e07>,</span> TimeUnit<span style=color:#719e07>.</span>SECONDS<span style=color:#719e07>);</span>
    <span style=color:#719e07>}</span>
<span style=color:#719e07>}</span>
</code></pre></div><h3 id=性能优化方案>性能优化方案</h3><ol><li>共享 handler <code>@ChannelHandler.Sharable</code></li><li>压缩 handler - 合并编解码器 —— MessageToMessageCodec</li><li>虽然有状态的 handler 不能搞单例，但是你可以绑定到 channel 属性上，强行单例</li><li>缩短事件传播路径—— 放 Map 里，在第一个 handler 里根据指令来找具体 handler。</li><li>更改事件传播源—— 用 ctx.writeAndFlush() 不要用 ctx.channel().writeAndFlush()</li><li>减少阻塞主线程的操作—— 使用业务线程池，RPC 优化重点</li><li>计算耗时，使用回调 Future</li></ol></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/tags/netty>netty</a></li></ul></nav></div><script src=https://utteranc.es/client.js repo=xiaoheiAh/xiaoheiAh.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div>© Copyright notice | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>