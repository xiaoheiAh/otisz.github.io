<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Netty - HashedWheelTimer 时间轮解析 - xiaoheiAh's blog</title><link rel=icon type=image/png href=https://blog.xiaohei.im/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Netty - HashedWheelTimer 时间轮解析"><meta property="og:description" content="java | 时间轮 ｜ netty ｜ HashedWheelTimer"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.xiaohei.im/posts/hashedwheeltimer/"><meta property="article:published_time" content="2020-06-06T16:46:38+08:00"><meta property="article:modified_time" content="2020-06-06T16:46:38+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Netty - HashedWheelTimer 时间轮解析"><meta name=twitter:description content="java | 时间轮 ｜ netty ｜ HashedWheelTimer"><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://blog.xiaohei.im/css/main.css><link rel=stylesheet href="https://fonts.loli.net/css2?display=swap&family=Bitter&family=Noto+Sans+SC"><link rel=stylesheet type=text/css href=https://blog.xiaohei.im/css/dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://blog.xiaohei.im/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://blog.xiaohei.im/>xiaoheiAh's blog</a></h1><div class=site-description><h2>Java Developer | 关注后端</h2><nav class="nav social"><ul class=flat><a href=https://github.com/xiaoheiAh title=xiaoheiAh><i data-feather=github></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/awesome>Awesome</a></li><li><a href=/cheatsheet>CheatSheet</a></li><li><a href=/about>About</a></li></ul></nav></div><div class=post-header><h1 class=title>Netty - HashedWheelTimer 时间轮解析</h1><div class=meta style=display:inline>Posted at &mdash; Jun 6, 2020</div><div class=meta style=display:inline></div></div><div class=markdown><h3 id=前言>前言</h3><p>在看<a href=https://mp.weixin.qq.com/s/JRsbK1Un2av9GKmJ8DK7IQ?>这篇文章</a>的时候对其中超时控制一块儿有点好奇。通过时间轮来控制超时？啥是时间轮？怎么控制的？文章会先介绍常见的计时超时处理，再引入时间轮介绍及 netty 在实现时的一些细节，最后总结下实现的一些优缺点。个人观点，如有错误望指正。</p><h3 id=计时超时>计时/超时</h3><p>JDK 中有许多经典的计时/超时计算的实现。例如 <strong>AQS</strong> 中的 <code>doAcquireNanos</code>, <strong>FutureTask</strong> 中的 <code>awitDone</code>, 从原理上来讲都是通过以下这种两种计时方式来实现的。</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200603221041.png alt=original-timeout></p><p>这里有两个问题：</p><ol><li><p>为什么要用 <strong>LockSupport.parkNanos</strong> 不用 <strong>Object.wait/Thread.sleep</strong>?</p><p>LockSupport 是使用 · 来实现底层操作，比如 <code>park/unpark</code>，源码文档开头第一句是 LockSupport 是创建锁或其他同步类的基本线程同步原语(p.s. 个人觉得就是基本工具的意思吧)。根据文档内容我整理了几个要点：</p><ul><li><p>使用 LockSupport 需要每个线程关联一个 permit，类似于 Semaphore 信号量同步类计数的原理，只是不会像 Semaphore 一样累加，类似于只有 0/1 两个值。调用 park 阻塞 permit 为 0，调用 unpark 恢复 permit 为 1。</p></li><li><p>由于 permit 的原因，线程之间的竞争具有活性（liveness），非 0 即 1，不会产生死锁。</p></li><li><p>no reason return：只要 unpark 就会在任何时候恢复，所以一般建议在循环中使用，时刻检查循环条件，所以 park 其实是自旋的一种优化，避免长时间空转。</p><p></p></li></ul><p>有三种情况会从休眠中唤醒：</p><ol><li>unpark 调用</li><li>其他线程调用了休眠线程的 interrupt，但不会抛出 <code>InterruptedException</code></li><li>虚调用（这个不太了解。。）</li></ol><p>回到问题，为什么不使用 <strong>Object.wait</strong> ？个人认为是因为我们不能保证 wait 是在 notify/notifyAll 之前执行的。如果在之后，就会一直阻塞下去。</p><p>为什么不用 <strong>Thread.sleep</strong>?个人认为首先需要要处理 <code>InterruptedException</code> ，其次 sleep 必须休眠设定的时间，无法中途唤醒。</p></li><li><p>为什么要用 <strong>System.nanoTime</strong> 不用 <strong>System.currentTimeMillis</strong>?</p><p><strong>currentTimeMillis</strong> 返回的是当前时间和 <strong>1970.01.01 midnight</strong> 之间的差值。如果发生时钟回拨或者手动把时钟改到以前，两次记录的时间差值就有可能为负了。</p><p><strong>nanoTime</strong> 在 JDK 文档中是建议用来做耗时计算的。nanoTime 并不是严格意义上的时间，只是 JVM 实例启动后随机选取的一个固定且任意的原点时间（可能是未来时间，值有可能为负数）开始计时。所以正确使用 nanoTime 的姿势是：</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#586e75>// 耗时计算
</span><span style=color:#586e75></span><span style=color:#dc322f>long</span> startTime <span style=color:#719e07>=</span> System<span style=color:#719e07>.</span>nanoTime<span style=color:#719e07>();</span>
<span style=color:#dc322f>long</span> estimatedTime <span style=color:#719e07>=</span> System<span style=color:#719e07>.</span>nanoTime<span style=color:#719e07>()</span> <span style=color:#719e07>-</span> startTime<span style=color:#719e07>;</span>
   
<span style=color:#586e75>// 比较两个时间
</span><span style=color:#586e75></span><span style=color:#dc322f>long</span> t0 <span style=color:#719e07>=</span> System<span style=color:#719e07>.</span>nanoTime<span style=color:#719e07>();</span>
<span style=color:#dc322f>long</span> t1 <span style=color:#719e07>=</span> System<span style=color:#719e07>.</span>nanoTime<span style=color:#719e07>();</span>
<span style=color:#586e75>// 由于存在溢出的问题
</span><span style=color:#586e75>// t0 &lt; t1 不一定成立，比如 t0 是正数，t1 溢出成负数了
</span><span style=color:#586e75>// 所以应该使用 t1 - t0 &lt; 0
</span></code></pre></div></li></ol><h3 id=时间轮算法>时间轮算法</h3><p><img src=https://i.loli.net/2020/06/06/kIhvDlYaCwqFpu8.png alt=image.png></p><p>超时的本质个人理解也的确是处理未来到达的定时任务，通过上述的方式可以控制超时需要每个线程独自控制，时间轮的这种方式更适合异步批量。Netty 针对 I/O 超时控制做了一些优化，参考<a href=http://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z>这篇论文</a>实现了 <code>HashedWheelTimer</code>。从上图可知，时间轮会分为固定长度的 bucket，任务根据设定的 delay 时间计算放入指定的 bucket, 同一个 buket 下通过双向链表相连。其实就是一个 <code>HashMap</code> 。<code>HashedWheelTimer</code> 会通过一个线程循环的查每个 bucket 下有哪些已经可以执行的定时任务并执行。从上面的图也可以发现，不同 delay 的定时任务也可能会落到同一个 bucket 下，但并不代表触发时间是相同的，比如上图中有 10 个 tick，定时 1s 和 11s 都会落在 <code>tick 1</code> 上，但定时 11s 应该在下一轮时才触发。所以应该还要记录每个任务需要在第几轮触发。</p><h4 id=使用案例>使用案例</h4><p>基于 Netty 的中间件有很多，大多都会用到这个 Timer 来做些事情。下面的案例源码来自蚂蚁开源的 <a href=https://github.com/sofastack/sofa-bolt>sofa-bolt</a>。</p><ol><li><p>一次正常的异步请求超时控制</p><p>sofa-bolt 中的自行封装的异步请求是与 JDK 中行为一致的。调用后立即返回，通过 <code>future.get()/get(long timeout, TimeUnit unit)</code>,获取调用结果。</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200530194516.png alt=invokeWithFuture></p></li><li><p>心跳检测超时控制</p><p>sofa-bolt 的实现借用了 Netty 的 <strong>IdleStateEvent</strong> 触发, 逻辑很简单，就是通过特殊的心跳命令定时去检查连接是否还在线，记录心跳失败的次数，超过设定阈值就抛出异常。所以分为以下两步:</p><ol><li><p>构建一个定时任务触发超时的逻辑</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200531192630.png alt=new-timeout></p></li><li><p>根据 response 处理心跳</p><p>处理心跳会在连接上添加一个 <code>Listener</code>，当收到响应时触发。</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200531221011.png alt=invokeCallbackListener></p></li></ol><p>源码挺好看懂，详细了解可以：<a href=https://github.com/sofastack/sofa-bolt/blob/7815d1058d705fa115d23323e2e525dbfcdcc4da/src/main/java/com/alipay/remoting/rpc/protocol/RpcHeartbeatTrigger.java#L67>:point_right: 点这里</a></p></li></ol><h3 id=实现细节>实现细节</h3><p><img src=https://i.loli.net/2020/06/06/kIhvDlYaCwqFpu8.png alt=image.png></p><p>还是需要看下这个图，从图中可以大致看到构造一个时间轮需要的属性。</p><ol><li>wheelSize：一个时间轮需要设置多少个 Tick, 默认是 512 个，size 默认会向上取值到最接近的 2 次幂，毕竟位运算计算下标时有奇效。</li><li>tickDuration: 每一个 tick 时长的设置。默认是 100 ms。这里如果设置太长可能会积压很多任务在一个 tick 上。</li></ol><blockquote><p>官方建议：不要创建太多 HashedWheelTimer 的实例。时间轮应该是共享的，而不是频繁的创建。并且 HashedWheelTimer 在初始化的时候都会创建一个 worker 线程进行调度，频繁创建也会造成很大的消耗。</p></blockquote><p>所以可以看到在 sofa-bolt 中获取实例是通过单例来处理的。</p><p></p><h4 id=属性>属性</h4><p>HashedwheelTimer 使用无锁编程的风格来实现了时间轮算法。所以大量使用了 JUC 下的工具类，是学习并发编程的模版案例了。</p><p></p><h4 id=hashedwheelbucket--hashedwheeltimeout>HashedWheelBucket & HashedWheelTimeout</h4><ol><li><p>HashedWheelBucket 用于存储每个 tick 上的超时任务，是个链表结构，有记录头尾节点，通过 bucket 来完成 timeout 的增删改。节点当然就是 <code>HashedWheelTimeout</code> ，<code>HashedWheelTimeout</code> 记录着前后节点，所以就形成了双端队列。</p><table><thead><tr><th align=left>HashedWheelBucket</th><th>HashedWheelTimeout</th></tr></thead><tbody><tr><td align=left><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200603204236.png alt=HashedWheelBucket></td><td><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200603214455.png alt=HashedWheelTimeout></td></tr></tbody></table></li><li><p>链表还支持支持从中间删除，原因是 HashedWheelTimeout 是中有记录自己是在那个 bucket 里，删除的时候使用自己所属的 bucket 来删除自己（我删我自己？）</p><p></p></li><li><p>Bucket 删除定时任务的逻辑，就是简单的链表删除是不是略显枯燥？</p><p></p></li></ol><h4 id=尽早-return>尽早 Return</h4><p><img src=https://i.loli.net/2020/06/06/5OZnHIemiq8XrGE.png alt=image.png></p><p>如果能看懂这个图的话，就不用往下看了，尽早return，下面都是字看着累。彩色的线是 worker 在运行状态下会循环做的几个操作。</p><ol><li>删除存在 cancelledTimeouts 队列中的失效任务</li><li>将缓存在 timeouts 队列中的新任务存放到时间轮上</li><li>执行该段时间内需要触发的定时任务</li></ol><h4 id=构造器>构造器</h4><p>构造就是对上述的未赋值的属性做一些补充。节约篇幅展示一些细节：</p><ol><li><p>构造的时候需要根据设置的 <strong>ticksPerWheel</strong> 创建对应的一个时间轮 <strong>Bucket</strong> 数组。用于在每个 tick 中存放对应的超时任务，并且还会把 <strong>ticksPerWheel</strong> 匹配到最近的 2 次幂上，方便位运算计算下标。</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200602200114.png alt=normalizeBucket></p></li><li><p>实例限制，最大 64 个时间轮实例</p><p><img src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200602200711.png alt=instance-limit></p></li></ol><h4 id=创建超时任务>创建超时任务</h4><p>从上述 sofa-bolt 的使用案例中可以看出，一切都是从 <code>newTimeout</code> 开始的，然后就结束了(开箱即用.jpg)&mldr;事实上这也就是最核心的逻辑了。看源码的话，省略掉一些参数校验的代码，就剩就十几行。一眼看下去应该也就会好奇<code>start()</code> 里面的逻辑。</p><p><img src=https://i.loli.net/2020/06/03/tPkd4rTsjVxNXvp.png alt=newTimeout></p><p><code>start</code> 方法的逻辑也简单，就是启动 woker 线程。有个需要注意的点是，<code>start</code> 方法会使用 <code>startTimeInitialized(countDownLatch)</code> 阻塞等待 <code>startTime</code> 赋值完成，毕竟 <code>startTime</code> 是后续超时比较的依据。</p><p><img src=https://i.loli.net/2020/06/03/BtNjoHSFAJIyu9L.png alt=woerkStart></p><h4 id=worker>Worker</h4><p>woker 线程是 HashedWheelTimer 的核心，实现了 <code>Runnable</code> 接口。我们通过 <code>newTimeout</code> 创建的定时任务，并不会直接放到时间轮上，而是缓存起来，当 woker 跑起来之后遍历到哪个 tick 就会把缓存队列里对应的这个 tick 下的定时任务放到 bucket 里，然后执行该 tick 下允许触发定时的 timeout。woker 线程在启动后只要没有被关闭就会不停的扫描下去。</p><p><img src=https://i.loli.net/2020/06/06/ji5FINPT8vhOfWy.png alt=worker-run></p><h5 id=waitfornexttick>waitForNextTick</h5><p><img src=https://i.loli.net/2020/06/03/qBOYxyHG7JNPg2p.png alt=image.png></p><h5 id=向-bucket-添加定时任务>向 Bucket 添加定时任务</h5><p>这里会把缓存在 <code>MpscQueue</code> 中的 Timeout 转移到 bucket 中，计算出正确的 bucketIndex 以及对应的轮数。</p><p></p><h5 id=执行超时任务>执行超时任务</h5><p>触发超时的逻辑很简单，整个流程是标准的双向链表增删改。需要注意的是，文章开头所说的不同定时任务可能活落到同一个 bucket 上，此时需要根据 <code>remainingRrounds</code> 判断是否在当前 tick 下执行。</p><p><img src=https://i.loli.net/2020/06/03/WySJ9kKOtgLdrDn.png alt=expireTimeouts></p><h3 id=总结>总结</h3><p><code>HashedWheelTimer</code> 加上注释只有 800+ 行代码，代码通俗易懂且精巧，非常值得借鉴学习。文章只介绍了新建定时任务的流程，其实还有取消，终止等等的处理，都是值得一看的。当然还是有些不足的地方：</p><ol><li><code>HashedWheelTimer</code> 适合于<strong>短平快</strong>的业务，由于 <strong>worker</strong> 是单线程的，耗时过长的定时任务会导致后续的任务阻塞。所以可以看到使用案例基本上都是立即返回的。批量耗时的任务还是应该使用业界流行的定时任务框架。</li><li>内存占用会比较大。前文有说过在创建定时任务的时候并不会直接放到 bucket 里而是先放到一个 <code>MpscQueue</code> 里，当 <strong>worker</strong> 走到定时任务所在的 tick 时才会将其添加进去。而且 bucket 本身数组 + 链表也会有很大的内存占用。</li><li>如果任务时间跨度过大，<strong>remainingRounds</strong> 会特别大，如果期间没有其他的定时任务就会空转很长时间，浪费资源。对此 <strong>Kafka</strong> 有给出优化的方案：<strong>层级时间轮</strong>，根据时分秒都设置一个时间轮，粒度细分也更好控制。</li></ol><h3 id=参考>参考</h3><ol><li><a href=https://www.cnkirito.moe/timer/>定时器的几种实现方式</a></li><li><a href=https://mp.weixin.qq.com/s/JRsbK1Un2av9GKmJ8DK7IQ?>sofa-bolt 介绍</a></li></ol></div><div class=post-tags></div><script src=https://utteranc.es/client.js repo=xiaoheiAh/xiaoheiAh.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div class=badge><img src=https://img.shields.io/badge/PV-6232-green alt=pv>
<img src=https://img.shields.io/badge/UV-1767-green alt=uv>
<img src="https://img.shields.io/badge/License-CC%20BY%20NC%20ND%204.0-green?link=http://creativecommons.org/licenses/by-nc-nd/4.0/" alt="CC BY NC ND 4.0">
<span>| © 2019 | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></span></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>