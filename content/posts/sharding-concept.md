---
title: "了解分库分表"
date: 2020-01-09T14:09:30+08:00
draft: true
tags: ["HA","DB"]
categories: ["数据库"]
description: "数据库|分库分表|高性能|snowflake|平滑迁移|中间件"
featured_image: 
---

<!--more-->

> 参考文章
>
> 1. 分库分表选型 https://juejin.im/post/5bf778ef5188251b8a26ed8b
> 2. 数据库中间件详解 https://zhuanlan.zhihu.com/p/87144535



### 为什么要分库分表

业务增长快，数据库压力大。主从复制或者说读写分离这种方式已经不能满足业务的需求，主从只能提升读的能力，写还是瓶颈。但是分库分表以后，读写能力都上来了。但是学习成本，维护成本也相应的上来了。

### 如何实现分库分表？

分库分表的路由规则一般为: 2^n 库 * 2^n 表,2 的幂次有利于后续的扩容。假设 n = 2 就是分 4 个库，每个库分 4 张表。

1. #### 以什么维度切分数据？

   主键/用户 Id/年月，具体问题具体分析

2. #### 唯一 ID 怎么设计？

   主流都是通过 `snowflake` 算法进行改造或者直接实现的。美团有开源 [Leaf](https://github.com/Meituan-Dianping/Leaf) 分布式 ID 生成的解决方案。

   ![snowflake](https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20200109194328.png)

### 动态扩容数据如何平滑迁移？

一般 ID 生成都是通过模除的方式确定路由的。假设目前分了两个库，根据 userId 进行切分。

1. 扩容前：userId % 2 路由到 db01/db02
2. 扩容新增数据库实例并新增表后需要修改业务系统或者数据库中间件中的数据库连接。以及 ID 路由计算的策略。扩容还得是 2 的 N 次幂。比如说扩到 4 个库了。库路由的策略就是 userId % 4 。

此时数据不是均衡的，因为新库没有数据。理论上应该先让新建的库与 db01/db02 进行 binlog 同步，比如：db03 同步 db01, db04 同步 db02, 然后设置 userId % 4 =0/2 时都走 db01, userId % 4 = 1/3 时都走 db02。同步一段时间后也已经将历史数据都同步完了，那么就可以讲规则改成正常的了，即 user%4 = 0 => db01, user%4 = 2 => db03...然后把 db01 中 userId % 4 = 2 的数据删掉，db03 中 userId % 4 = 0的数据删掉，至此数据都减半了。读写能力都上来了。也算平滑迁移了吧。

### 分库分表后数据如何查询？复杂查询如何实现？分页如何做？

查询秉承的原则是尽量使用切分 ID 来查询，如果是较为复杂的数据最好是大事化小小事化了。个人理解复杂的查询不应该在用户的交互流程中出现，如果有的话应该也是可以优化转换的。像淘宝这种都是以用户为维度的，分库分表切分的时候应该也是会从用户的角度来作切分。那么用户的订单，用户的物流信息都是可以直接索引到对应的库。查起来就好查。分页也就好做了。

如果是复杂的分页最好能记录 `offset`，用户交互上尽量不使用常规分页，即只保留下一页（单页跳转）这种跳转。通过这种操作，用户点击下一页时，只需要去查询出多个库的 `param > offset limit pagesize`条数据，在内存中再拼接排序成一页。

#### 主流的分库分表中间件原理？

主流中间件分为两类：`Proxy` 和 `Smart Client`

#### 可能遇到的问题

1. 数据库连接不够用

   如果使用 `sharding-jdbc` 这样的驱动层中间件，需要在项目中维护到所有分库的连接。项目实例过多时连接爆炸。。。

   如何解决呢？直接让每个实例只连接对应的一个库，从网关层就确定分库位置，然后就将请求打到连接这个库的实例上。

2. 数据聚合（`count`, `sum`）在业务系统中

